{"meta":{"title":"Fighting","subtitle":"记二三事而已","description":"The biggest adventure you can take is to live the life of your dreams","author":"Zhouheng","url":"http://blogzhou.top"},"pages":[{"title":"Categories","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"categories/index.html","permalink":"http://blogzhou.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"tags/index.html","permalink":"http://blogzhou.top/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"about/index.html","permalink":"http://blogzhou.top/about/index.html","excerpt":"","text":"I am what I am, 我永远都爱这样的我。 免责声明: 鄙人在此发文，记二三事而已，少许借鉴，皆注明出处，如版权归属者存有异议，还请告知。文皆随意敲击键盘所出，用以检验本人电脑键盘录入、屏幕显示、鼠标定位性能，非吾志也。 email：fm939071955@163.com Music Oops Now I have come to the crossroads in my life.I always knew what the right path was.Without exception,I knew,but I never took it.You know why?It was too damn hard!"}],"posts":[{"title":"几种常见的排序","slug":"几种常见的排序","date":"2018-05-03T06:42:15.000Z","updated":"2018-05-04T13:25:26.674Z","comments":true,"path":"2018/05/03/几种常见的排序/","link":"","permalink":"http://blogzhou.top/2018/05/03/几种常见的排序/","excerpt":"1.选择排序 比较后，符合条件每次都进行交换。 123456789for (int i= 0;i&lt;cnt-1;i++)&#123;for (int j=i + 1;j&lt;cnt;j++)&#123;if(array[i]&lt;array[j])&#123;int tmp=array[i];array[i]=array[j];array[j]=tmp;&#125;&#125;&#125; 比较后，符合条件，不立即交换，记住索引，内循环完成交换一次。 1234567891011for (int i = 0; i &lt; cnt - 1; i++) &#123;int tmp = 0;for (int j = i + 1; j &lt; cnt; j++) &#123;if (array[i] &lt; array[j]) &#123;tmp = j;&#125;int c = array[i];array[i] = array[tmp];array[tmp] = c;&#125;&#125;","text":"1.选择排序 比较后，符合条件每次都进行交换。 123456789for (int i= 0;i&lt;cnt-1;i++)&#123;for (int j=i + 1;j&lt;cnt;j++)&#123;if(array[i]&lt;array[j])&#123;int tmp=array[i];array[i]=array[j];array[j]=tmp;&#125;&#125;&#125; 比较后，符合条件，不立即交换，记住索引，内循环完成交换一次。 1234567891011for (int i = 0; i &lt; cnt - 1; i++) &#123;int tmp = 0;for (int j = i + 1; j &lt; cnt; j++) &#123;if (array[i] &lt; array[j]) &#123;tmp = j;&#125;int c = array[i];array[i] = array[tmp];array[tmp] = c;&#125;&#125; 2.冒泡排序12345678910/* 冒泡排序 */for (int i = 0; i &lt; cnt - 1; i ++) &#123;for (int j = 0; j &lt; cnt - i - 1; j ++) &#123;if (array[j] &lt; array[j + 1]) &#123;int tmp = array[j];array[j] = array[j + 1];array[j + 1] = tmp;&#125;&#125;&#125; 3.插空排序 代码解析见注释。 123456789int a[5]=&#123;9,8,10,2,20&#125;;int key,j;// key为每次被拿出的值（也就是初始提供“空”的值），j为要比较到的最大索引for (int i=1; i&lt;5; i++) &#123;// 直接插入排序key=a[i];// 取出当前要比较项for (j=i-1; j&gt;=0&amp;&amp;a[j]&gt;key; j--) &#123;// 和直到索引j位置的元素逐一比较a[j+1]=a[j];// j为更新出来的新空（但是只要进了循环，此次循环结束就会进行一次j--操作，所以下面要+1）&#125;a[j+1]=key;// j+1为最后留给key的空&#125; 整体测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#import &lt;Foundation/Foundation.h&gt;void initArray(int array[],int cnt);void selectSortForArray(int array[],int cnt);void showArray(int array[],int cnt);void initArray(int array[],int cnt)&#123;for(int i= 0;i&lt;cnt;i++)array[i] = arc4random() % 100;&#125;void selectSortForArray(int array[],int cnt)&#123;/*for (int i = 0; i&lt;cnt-1; i++)&#123;for (int j = i+1; j&lt;cnt; j++)&#123;if (array[i] &lt; array[j]) &#123;int tmp = array[i];array[i] = array[j];array[j] = tmp;&#125;&#125;&#125;*///****************这样每次比较后都交换元素位置**********for (int i= 0;i&lt;cnt-1;i++)&#123;for (int j=i + 1;j&lt;cnt;j++)&#123;if(array[i]&lt;array[j])&#123;int tmp=array[i];array[i]=array[j];array[j]=tmp;&#125;&#125;// &#125;//*****************这样每次比较只记住索引，内循环遍历一次完成后再交换（减少交换次数），*********for (int i = 0; i &lt; cnt - 1; i++) &#123;int tmp = 0;for (int j = i + 1; j &lt; cnt; j++) &#123;if (array[i] &lt; array[j]) &#123;tmp = j;&#125;int c = array[i];array[i] = array[tmp];array[tmp] = c;&#125;&#125;/* 冒泡排序 */for (int i = 0; i &lt; cnt - 1; i ++) &#123;for (int j = 0; j &lt; cnt - i - 1; j ++) &#123;if (array[j] &lt; array[j + 1]) &#123;int tmp = array[j];array[j] = array[j + 1];array[j + 1] = tmp;&#125;&#125;&#125;&#125;void showArray(int array[],int cnt)&#123;for (int i = 0; i&lt;cnt; i++) &#123;printf(&quot;%d &quot;,array[i]);&#125;printf(&quot;\\n&quot;);&#125;int main(int argc, const char * argv[])&#123;@autoreleasepool &#123;// insert code here...// NSLog(@&quot;Hello, World!&quot;);//int array[10] = &#123;0&#125;;initArray(array, 10);showArray(array,10);selectSortForArray(array, 10);showArray(array,10);// C-实现 插空排序int a[5]=&#123;9,8,10,2,20&#125;;int key,j;// key为每次被拿出的值（也就是初始提供“空”的值），j为要比较到的最大索引for (int i=1; i&lt;5; i++) &#123;// 直接插入排序key=a[i];// 取出当前要比较项for (j=i-1; j&gt;=0&amp;&amp;a[j]&gt;key; j--) &#123;// 和直到索引j位置的元素逐一比较a[j+1]=a[j];// j为更新出来的新空（但是只要进了循环，此次循环结束就会进行一次j--操作，所以下面要+1）&#125;a[j+1]=key;// j+1为最后留给key的空&#125;for (int i=0; i&lt;5; i++) &#123;// NSLog(@&quot;%i&quot;,a[i]);&#125;// OC实现// NSMutableArray *array=[NSMutableArray arrayWithObjects:@9,@8,@10,@2,@20, nil];// id key;// NSInteger j;// for (NSInteger i=1; i&lt;array.count; i++) &#123;// key=[array objectAtIndex:i];//取到每一个待插入的数据,从a[1]开始查找// for (j=i-1; j&gt;=0&amp;&amp;array[j]&gt;key; j--) &#123;// // 如果之前的数比key大,就将这个数向后移动一个位置,留出空来让key插入就像整牌一样//// [array exchangeObjectAtIndex:j+1 withObjectAtIndex:j];//交换// &#125;// [array replaceObjectAtIndex:j+1 withObject:key];// &#125;// for (key in array) &#123;// NSLog(@&quot;%@&quot;,key);// &#125;printf(&quot;\\n&quot;);&#125;return 0;&#125;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"code","slug":"code","permalink":"http://blogzhou.top/tags/code/"}]},{"title":"Node环境配置","slug":"Node环境配置","date":"2018-03-12T01:43:45.000Z","updated":"2018-04-14T00:36:27.327Z","comments":true,"path":"2018/03/12/Node环境配置/","link":"","permalink":"http://blogzhou.top/2018/03/12/Node环境配置/","excerpt":"方式一：安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本）","text":"方式一：安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） 方式二：NVM工具的使用 Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 安装操作步骤一 、Mac OS： 比较简单，自行参考这个链接地址 https://github.com/creationix/nvm二、Windows： 下载：nvm-windows 解压到一个全英文路径 编辑解压目录下的settings.txt文件（不存在则新建）文件内容如图： root 配置为当前 nvm.exe 所在目录 path 配置为 node 快捷方式所在的目录 arch 配置为当前操作系统的位数（32/64） proxy 不用配置 配置环境变量 可以通过 window+r : sysdm.cpl TMP下新建 NVM_HOME = 当前 nvm.exe 所在目录 NVM_SYMLINK = node 快捷方式所在的目录 PATH += %NVM_HOME%;%NVM_SYMLINK%; 打开CMD通过set [name]命令查看环境变量是否配置成功 PowerShell中是通过dir env:[name]命令 NVM使用说明： https://github.com/coreybutler/nvm-windows/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://blogzhou.top/tags/tool/"}]},{"title":"Favorite Words","slug":"Favorite Words","date":"2018-03-08T03:25:54.000Z","updated":"2018-07-07T10:20:10.990Z","comments":true,"path":"2018/03/08/Favorite Words/","link":"","permalink":"http://blogzhou.top/2018/03/08/Favorite Words/","excerpt":"那些动听的想法如果不能趁年轻易感的时候去实现，消逝的速度比云还快。 即使有人告诉我，山的那边还是山，我依然想一路小跑翻山越岭，亲自感慨：“我靠！他说的是真的诶！” 与天地等量齐观的眼界 永远不要指望有人会明白你在说什么，别相信什么切肤之痛，别相信什么感同身受，你就是你，独一无二的你，你的那些情绪、想法、念头，别人无法感知，亦无法理解。 —— 独木舟","text":"那些动听的想法如果不能趁年轻易感的时候去实现，消逝的速度比云还快。 即使有人告诉我，山的那边还是山，我依然想一路小跑翻山越岭，亲自感慨：“我靠！他说的是真的诶！” 与天地等量齐观的眼界 永远不要指望有人会明白你在说什么，别相信什么切肤之痛，别相信什么感同身受，你就是你，独一无二的你，你的那些情绪、想法、念头，别人无法感知，亦无法理解。 —— 独木舟 佛曰，人生有八苦：生，老，病，死，爱别离，怨长久，求不得，放不下。 佛曰：命由己造，相由心生，世间万物皆是化相，心不动，万物皆不动，心不变，万物皆不变。 佛曰：坐亦禅，行亦禅，一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静体自然。 佛说：万法皆生，皆系缘份，偶然的相遇，暮然的回首，注定彼此的一生，只为眼光交汇的刹那。 缘起即灭，缘生已空。 这不是你梦寐以求的长大吗，你怎么愁眉不展？– 别辜负 你恋爱了，只是你爱的人，有时并不真的存在。他可能只是一堵无辜的白墙，被你狂热的，把你心里最向往的爱情电影，全部在他身上投影一遍。 因为我刚才看到你，觉得你挺可爱的，但我不知道该不该跟你搭讪，所以我问自己，我该不该认识她呢？答案是，我没有理由不去认识她。 朋友，记住一条简单的惯性定律:静止的倾向于静止，运动的倾向于运动。不知道一件事情怎么开始才合适？先去做10分钟。不知道怎么和女孩搭讪？立马过去说一声:“你好！……”后面的你自然会接着说。动起来，运动的倾向于运动。 父母所想永远是避免子女受到伤害，而子女所想永远是如何才能不枉此生。这场博弈注定有一方让步，一方喜笑颜开。 未来一百年乃至一千年一万年，很难看到强人工智能的出现。因为人类对智能本质的了解其实太少了。无知者无畏，正因为我们的肤浅，所以才盲目的乐观，“人工智能的奇点”出现在2050年根本就是无稽之谈。人类目前靠有限的一点数学算法对智能死板的模拟，比大自然的精巧的进化创造，简直是天壤之别。套用别人对“深度学习”算法的评价：“梯子很长，但还远远够不到月亮”。— Daniel 快乐分享错了人，成为了炫耀，难过分享错了人，成了矫情。 以前觉得，年少时的喜欢不算什么，长大以后，还有许多壮阔的温柔在前方。但其实并不是这样，年少时的喜欢其实浓度最高，高到你以为你不在乎不喜欢了，其实关于喜欢的细枝末节都深深地扎根在心里，以至于以后遇到的所有人，都比不上当初的那个男孩或女孩所带来的心动。 所以啊，如果再遇见你，我不想给自己留下遗憾。 人们总是对喜欢的人不说我喜欢你 却说我想你对想见的人不说我想你 却说要不要一起吃个饭 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。 曾经我自诩半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。唯独见了你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。— 网易云音乐《起风了》热评 浮萍漂泊本无根 天涯游子君莫问","categories":[{"name":"favwords","slug":"favwords","permalink":"http://blogzhou.top/categories/favwords/"}],"tags":[{"name":"Words","slug":"Words","permalink":"http://blogzhou.top/tags/Words/"}]},{"title":"My Words","slug":"MyWords","date":"2018-03-07T10:32:41.000Z","updated":"2018-04-14T00:36:27.327Z","comments":true,"path":"2018/03/07/MyWords/","link":"","permalink":"http://blogzhou.top/2018/03/07/MyWords/","excerpt":"","text":"为了锦绣前程也好，花样人生也罢，然而，还是恨透了 别离。 长大，淡然了许多事，唯别离愈发的难以释怀。","categories":[{"name":"favwords","slug":"favwords","permalink":"http://blogzhou.top/categories/favwords/"}],"tags":[{"name":"Words","slug":"Words","permalink":"http://blogzhou.top/tags/Words/"}]},{"title":"胡乱写写(My poetry)","slug":"胡乱写写-My-poetry","date":"2017-10-25T03:28:21.000Z","updated":"2018-07-07T10:16:36.328Z","comments":true,"path":"2017/10/25/胡乱写写-My-poetry/","link":"","permalink":"http://blogzhou.top/2017/10/25/胡乱写写-My-poetry/","excerpt":"远方 我来自哪里又将去向何方 满地的油菜花一望无际花海和天相接的地方是怎样一副景象 微风轻抚花儿轻摇 听有个声音在轻唤远方远方","text":"远方 我来自哪里又将去向何方 满地的油菜花一望无际花海和天相接的地方是怎样一副景象 微风轻抚花儿轻摇 听有个声音在轻唤远方远方 秋日初醒 清晨、初醒、微凉迷茫、迷茫、迷茫总是憧憬诗与远方但却不知如何前往入世三年有余不知前路何方时职实非吾志追梦又恐寒霜奈何格局所限只能困于这方将近而立之年身家三三两两父母意不可辜自身志不可负世间安有全法叫我谁都不负性本秋田南山却处在这红尘俗世间时下且顾眼前但愿不负明天 晚霞迎夜幕，手握相思土。往事一幕幕，而今你何处。 那年的初遇 在那落叶纷飞的季节在那初来乍到的校角在那冷冷清清的球场边在那历经沧桑的栅栏旁 你无意的回首映入眼帘的是那绝美的容颜 那双会笑的眼睛融化了秋日的寒霜春风拂面 如风陵渡口的初遇似得见面具下俊俏脸庞的郭襄你唤醒了我沉睡已久的悸动 从此校园里多了一双寻觅的眼睛世间多了一个相思的少年 你装点了我如梦的思念陪伴了我匆匆的那年 你给了我一场完美的邂逅让我明白什么是止于唇齿的爱恋 飞逝的四年定格的画面 它揉碎在记忆的长河里滋润着流年 玉来 玉楼窗旁桃花面，来去偏偏杨柳姿。是非对错红尘怨，女儿心思几人识。妆罢镜中妩媚娘，大可倾尽北国郎。老幼得见皆倾心，阿飞初识犹猖狂！ 啦啦啦 情言多矫揉做作人情深迷失自我节度失痴男怨女快愉寄霞友云朋乐情托北窗之友 随笔（1） 午夜梦回有你有我清晨初醒独望寒窗 随笔（2） 窗外的雨淅淅沥沥敲打着玻璃恍如昨日真的好像好像只是少了听雨的你 不见 人生因缺憾而完美不见也好至少在自我构建的王国中你永不会褪色 《傻傻的我》 我以为真的是因为怕生真的是需要慎重可你信一见钟情 我以为真的是因为季节真的是畏惧北风可我于你就是北风你等的不是吹南风的季节你等的是能让你沐浴南风的人 我以为真的能蹭一顿饭真的是想想就激动可女人都是骗子我能咋整。。。 看这傻傻的我 因果 前世的因今生的果一定是我前世与你的回眸不够今生才只能与你相忘于江湖 If I like you,I will take a few steps to your direction forwardly and a few more,if you see me coming and respond by nothing,I will stop.There are so many things in the world that we can get by fighting hard,but only for love,I don’t wanna try so hard.Two well-matched persons,fair and equal love and being loved.Live in such a rat-race kind of world,I wish I can get one love without trying too damn hard. 流年 总以为这一秒和上一秒没什么不同；总以为岁月不会如此匆匆；总以为自己still a little boy；……可这蓦然的回首，时间磨平了棱角，岁月消逝了朱颜。 —&gt;18.3.7 三尺微命一介布衣寄身于这天地间尚不能顾全自身冷暖凭何立室成家","categories":[{"name":"My poetry","slug":"My-poetry","permalink":"http://blogzhou.top/categories/My-poetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"如何清理XCode缓存","slug":"如何清理XCode缓存","date":"2017-10-23T06:12:44.000Z","updated":"2018-04-14T00:36:27.328Z","comments":true,"path":"2017/10/23/如何清理XCode缓存/","link":"","permalink":"http://blogzhou.top/2017/10/23/如何清理XCode缓存/","excerpt":"原文链接 一：移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData) 只要重新运行Xcode就一定会重新生成，而且会随着运行程序的增多，占用空间会越来越大。删除后在重新运行程序可能会稍微慢一点，建议定期清理。 路径： 1~/Library/Developer/Xcode/DerivedData","text":"原文链接 一：移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData) 只要重新运行Xcode就一定会重新生成，而且会随着运行程序的增多，占用空间会越来越大。删除后在重新运行程序可能会稍微慢一点，建议定期清理。 路径： 1~/Library/Developer/Xcode/DerivedData 二：移除 APP 打包的ipa历史版本(Archives) 删除后不可恢复，文件夹是按照日期排列的，所以如果你不想全部删除，就只保留最新的几个版本就好了，个人建议全部删除。 路径： 1~/Library/Developer/Xcode/Archives 三：移除 APP 打包的app icon历史版本(Archives) 删除后不可恢复，文件夹是Bundle Idenifier排列的，然后再按照archive的版本号排列的，如果你看每个版本内的内容，其实就是你的app icon，个人建议全部删除。 路径： 1~/Library/Developer/Xcode/Products/ 四：移除模拟器的缓存数据(Devices) 模拟器的相关数据。每个版本的模拟器占用的内存空间大约为10M左右。每个文件夹里包含的就是一个特定系统版本的设备的数据。每个文件夹对应哪个设备可以在其下device.plist中查看。删除之后，如果立即运行程序会报错，先关闭Xcode，再重新打开程序，运行即可。运行该路径下会立马生成模拟器对应版本的文件。 路径： 1~/Library/Developer/CoreSimulator/Devices/ 五：移除对旧设备的支持(iOS DeviceSupport) 一般是占用内存空间最大的文件夹，即使全部删，再连接设备调试时，会重新自动生成。一般iOS只向下兼容两个版本就可以了，所以我移除了9.0以下的所有版本。 路径： 1~/Library/Developer/Xcode/iOS DeviceSupport 六：移除 Xcode 中的无效的插件(Plug-ins) 因为之前你可能安装了一些 Xcode 的插件，比如HighlightSelectedString、VVDocumenter-Xcode等非常方便好用的第三方插件，在Xcode升级到version 8.0以后，就失效了，Xcode在内部已经集成了类似的方法，所以之前安装的也都没有用了，但是还在原来的位置占用着内存空间，建议删除。 路径： 12//如果你曾经没有安装过插件，那么可能不存在此路径。~/Library/Application Support/Developer/Shared/Xcode/Plug-ins 七：移除旧版本的模拟器支持 如果你不小心安装了很多个版本的模拟器，那么你可以删除一些旧版本的。但是当你需要旧版本的模拟器时，就需要重新下载了。建议留下1~2个版本就好了，其余的都删了吧。 路径： 1~/Library/Developer/CoreSimulator/Profiles/Runtimes/ 八：移除 playground 的项目缓存(XCPGDevices) 删除后可重新生成，可以全部删除。再次运行程序会缓存。 路径： 1~/Library/Developer/XCPGDevices/ 九：移除旧的文档(Docsets) 删除后不可恢复，该目录下存储的为开发文档，一般有三个文件com.apple.adc.documentation.iOS.docset(1.68GB)、com.apple.adc.documentation.OSX.docset(2.62GB)和com.apple.adc.documentation.Xcode.docset(256.4M)，如果你只做iOS开发，其实你可以把OSX.docset删除掉的，因为它占用了2.62GB的内存。 路径： 1~/Library/Developer/Shared/Documentation/DocSets 十：移除模拟器中的SDK版本(iPhoneSimulator.sdk) 不可恢复，操作请慎重。我个人的此路径下的只有最新版本的sdk，除非当你有多个版本的sdk再酌情删除。 路径： 12//注意：占用空间约4GB，删除时请慎重~/application/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/ By the way: 前往文件夹快捷键：Command + shift + G Xcode清除最近打开的文件列表：File -&gt; Open Recent -&gt; Clear Menu","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"XCode","slug":"XCode","permalink":"http://blogzhou.top/tags/XCode/"}]},{"title":"诗歌（inland）","slug":"诗歌（inland）","date":"2017-10-17T02:01:48.000Z","updated":"2018-04-14T00:36:27.329Z","comments":true,"path":"2017/10/17/诗歌（inland）/","link":"","permalink":"http://blogzhou.top/2017/10/17/诗歌（inland）/","excerpt":"《可遇不可求的事》— 冯唐后海有树的院子夏代有工的玉此时此刻的云二十来岁的你 故乡的云，上古的玉，随手的诗，此刻的你。","text":"《可遇不可求的事》— 冯唐后海有树的院子夏代有工的玉此时此刻的云二十来岁的你 故乡的云，上古的玉，随手的诗，此刻的你。 《致橡树》— 舒婷我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 《雨巷》—戴望舒撑着油纸伞，独自彷徨在悠长，悠长又寂寥的雨巷，我希望逢着一个丁香一样的结着愁怨的姑娘。她是有丁香一样的颜色，丁香一样的芬芳，丁香一样的忧愁，在雨中哀怨，哀怨又彷徨；她彷徨在这寂寥的雨巷，撑着油纸伞像我一样，像我一样地默默彳亍着，冷漠，凄清，又惆怅,她静默地走近走近，又投出太息一般的眼光，她飘过像梦一般的，像梦一般的凄婉迷茫。像梦中飘过一枝丁香的，我身旁飘过这女郎；她静默地远了，远了，到了颓圮的篱墙，走尽这雨巷。在雨的哀曲里，消了她的颜色，散了她的芬芳消散了，甚至她的太息般的眼光，丁香般的惆怅,撑着油纸伞，独自彷徨在悠长，悠长又寂寥的雨巷，我希望飘过一个丁香一样的结着愁怨的姑娘。 《再别康桥》—徐志摩轻轻的我走了，正如我轻轻的来；我轻轻的招手，作别西天的云彩。 那河畔的金柳，是夕阳中的新娘；波光里的艳影，在我的心头荡漾。 软泥上的青荇,油油的在水底招摇,在康河的柔波里，我甘心做一条水草！ 那榆荫下的一潭，不是清泉，是天上虹；揉碎在浮藻间，沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯,满载一船星辉，在星辉斑斓里放歌。 但我不能放歌，悄悄是别离的笙箫；夏虫也为我沉默，沉默是今晚的康桥！ 悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一片云彩。","categories":[{"name":"favpoetry","slug":"favpoetry","permalink":"http://blogzhou.top/categories/favpoetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"诗歌(foreign)","slug":"诗歌","date":"2017-10-16T02:40:45.000Z","updated":"2018-04-14T00:36:27.329Z","comments":true,"path":"2017/10/16/诗歌/","link":"","permalink":"http://blogzhou.top/2017/10/16/诗歌/","excerpt":"《I Strove with None》— Walter Savage Landor I strove with none,for none was worth my strife;Nature I lov’d, ，and next to Nature, Art;I warm’d both hands before the fire of life;It sinks,and I am ready to depart. 我和谁都不争，和谁争我都不屑；我爱大自然，其次就是艺术；我双手烤着，生命之火取暖；火萎了，我也准备走了。——[英]兰德（杨绛 译）","text":"《I Strove with None》— Walter Savage Landor I strove with none,for none was worth my strife;Nature I lov’d, ，and next to Nature, Art;I warm’d both hands before the fire of life;It sinks,and I am ready to depart. 我和谁都不争，和谁争我都不屑；我爱大自然，其次就是艺术；我双手烤着，生命之火取暖；火萎了，我也准备走了。——[英]兰德（杨绛 译） 《When You Are Old》— William Butler YeatsWhen you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes had once, and of their shadows deep;How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face;And bending down beside the glowing bars,Murmur, a little sadly, how love fledAnd paced upon the mountains overheadAnd hid his face amid a crowd of stars. 《当你老了》袁可嘉译当你老了，头白了，睡思昏沉在炉火旁打盹，请取下这部诗歌慢慢读，回想你过去眼神的柔和回想它们昔日浓重的阴影多少人爱你青春欢畅的时辰爱慕你的美丽，假意或真心只有一个人爱你朝圣者的灵魂爱你衰老了的脸上痛苦的皱纹垂下头来，在红火闪耀的炉子旁凄然地轻轻诉 说那爱情的消逝在头顶上的山上它缓缓地踱着步子在一群星星中间隐藏着脸庞","categories":[{"name":"favpoetry","slug":"favpoetry","permalink":"http://blogzhou.top/categories/favpoetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"iOS系统音量&屏幕亮度调节","slug":"iOS系统音量-屏幕亮度调节","date":"2017-10-12T07:35:14.000Z","updated":"2018-04-14T00:36:27.328Z","comments":true,"path":"2017/10/12/iOS系统音量-屏幕亮度调节/","link":"","permalink":"http://blogzhou.top/2017/10/12/iOS系统音量-屏幕亮度调节/","excerpt":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125;","text":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125; 监听系统物理按键调节音量12345678910/** 监听 */- (void)registerVolumeChangeEvent &#123;// NSError *error;// [[AVAudioSession sharedInstance] setActive:YES error:&amp;error]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeVolumeValueFunc) name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125;/** 移除 */- (void)unregisterVolumeChangeEvent &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125; 获取系统当前音量1[[AVAudioSession sharedInstance] outputVolume]; 二，屏幕亮度很简单就一句 123456789[[UIScreen mainScreen] setBrightness:值（0 ~ 1）]//示例 if (panPoint.y &lt; 0) &#123; //增加亮度 [[UIScreen mainScreen] setBrightness:self.startVB + (-panPoint.y / 30.0 / 10)]; &#125; else &#123; //减少亮度 [[UIScreen mainScreen] setBrightness:self.startVB - (panPoint.y / 30.0 / 10)]; &#125;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"UIButton重复点击解决方案","slug":"UIButton重复点击解决方案","date":"2017-10-12T07:33:26.000Z","updated":"2018-04-14T00:36:27.327Z","comments":true,"path":"2017/10/12/UIButton重复点击解决方案/","link":"","permalink":"http://blogzhou.top/2017/10/12/UIButton重复点击解决方案/","excerpt":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0;","text":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0; 2.声明一个方法及实现如下（思路很简单就直接上代码了）1234567891011121314/** * 根据传过来的时间间隔进行是否快速点击判断； * opIntervalTime ： 时间间隔，单位毫秒； **/+(bool)isFastDoubleClick1:(long)opIntervalTime&#123; NSDate* date = [NSDate dateWithTimeIntervalSinceNow:0]; long time = [date timeIntervalSince1970] * 1000; long intervalTime = time - LAST_CLICK_TIME1; if(0 &lt; intervalTime &amp;&amp; intervalTime &lt; opIntervalTime)&#123; return true; &#125; LAST_CLICK_TIME1 = time; return false;&#125; 参数说明注释写得很清楚，用法也很简单，就不多说了。 方式二（较主流）给UIButton写个分类（category）1.分类.h文件 12345#import &lt;UIKit/UIKit.h&gt;@interface UIButton (FMExtension)/** 两次点击最大时间间隔，在此时间内，所有点击事件不不执行 */@property (nonatomic, assign) NSTimeInterval fm_multipleClickInterval;@end 由于category 中声明的property，只会生成属性的方法而不会生成方法的实现及“_”变量，所以.m中要用runtime进行属性的动态绑定。2.分类.m 文件具体实现步骤2.1引入runtime头文件 12345678910#import &quot;UIButton+FMExtension.h&quot;#import &lt;objc/runtime.h&gt;@interface UIButton ()/** 记录上一次接收点击事件的时间 */@property(nonatomic, assign) NSTimeInterval fm_acceptEventTime;@end/** 关联关键字 */static const char *UIControl_multipleClickInterval = &quot;fm_multipleClickInterval&quot;;static const char *UIControl_acceptEventTime = &quot;fm_acceptEventTime&quot;;@implementation UIButton (FMExtension) 2.2动态关联对象1234567891011121314/** 动态关联对象 */- (void)setFm_multipleClickInterval:(NSTimeInterval)fm_multipleClickInterval &#123; //四个参数：源对象，关键字，关联的对象和一个关联策略 objc_setAssociatedObject(self, UIControl_multipleClickInterval, @(fm_multipleClickInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_multipleClickInterval &#123; return [objc_getAssociatedObject(self, UIControl_multipleClickInterval) doubleValue];&#125;- (void)setFm_acceptEventTime:(NSTimeInterval)fm_acceptEventTime &#123; objc_setAssociatedObject(self, UIControl_acceptEventTime, @(fm_acceptEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_acceptEventTime &#123; return [objc_getAssociatedObject(self, UIControl_acceptEventTime) doubleValue];&#125; 2.3交换方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//交换方法//以上主要是实现两个方法的互换,load是gcd的只shareinstance，果断保证执行一次+ (void)load &#123; //获取着两个方法 //系统方法 Method sysMethod = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:)); SEL sysM = @selector(sendAction:to:forEvent:); //自定义方法 Method myMethod = class_getInstanceMethod(self, @selector(fm_sendAction:to:forEvent:)); SEL myM = @selector(fm_sendAction:to:forEvent:); //添加方法进去（系统方法名执行自己的自定义函数，相当于重写父类方法） BOOL overrideSuccess = class_addMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); //如果添加成功 if (overrideSuccess) &#123; //自定义函数名执行系统函数 class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); &#125; else &#123; method_exchangeImplementations(sysMethod, myMethod); &#125; //这样也可以交换方法（但是注意顺序） /****** * *个人理解： *不管是add还是replace和系统重名的方法，都是相当于复制了一个和系统重名的函数（也就是 *相当于继承重写了父类方法 ps:分类中不支持继承！系统发现有这个方法会优先调用） *系统自动复制一个与自己同名的方法给开发人员用，但是method_getImplementation(systemMethod) *还是获取系统自带方法的属性 * ******/ /* class_replaceMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); */&#125;- (void)fm_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; if (NSDate.date.timeIntervalSince1970 - self.fm_acceptEventTime &lt; self.fm_multipleClickInterval) return; if (self.fm_multipleClickInterval &gt; 0) &#123; self.fm_acceptEventTime = NSDate.date.timeIntervalSince1970;//记录上次点击的时间 &#125; //这里并不是循环调用，由于交换了两个方法，fm_sendAction:to:forEvent:现在就是sendAction:to:forEvent: [self fm_sendAction:action to:target forEvent:event];&#125;@end 代码注释写的比较详细了（自我感觉还阔以吧），就不再多说什么。PS: 交换方法那，有个人的一点小小见解，不知道对不对，欢迎大牛批评指正！！！","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"类似“今日头条”频道编辑功能UI实现","slug":"类似“今日头条”频道编辑功能UI实现","date":"2017-10-12T07:32:08.000Z","updated":"2018-04-14T00:36:27.329Z","comments":true,"path":"2017/10/12/类似“今日头条”频道编辑功能UI实现/","link":"","permalink":"http://blogzhou.top/2017/10/12/类似“今日头条”频道编辑功能UI实现/","excerpt":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅）","text":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅） 之所以用着两位前辈的代码，是因为，虽然实现是同一UI效果，但是思路不同，下面一一讲解方式一：(对应前辈一的实现思路) 思路：完全自定义。自定义channelView（项目中名称：TouchView）继承于UIView,绑定需要的label，imageView，pan,tap,longPress手势，在对应的手势实现中计算出每个channel的index，然后刷新frame（具体实现请参考代码） 优点：自定义程度高，自定义功能的添加修改比较方便，尤其动画比较流畅； 缺点：要同时处理四个数组的数据（两个数据源的，两个视图的），frame刷新频率较高，且都是自己实现的frame刷新，性能可能不如原生的控件（只是可能） 我的完善：原框架功能已经比较完善，只是缺少个下滑移除功能（已添加） GIF效果图： 方式二：(对应前辈二的实现思路) 思路：在UICollectionView的基础上进一步的修改封装。（具体实现请参考代码） 优点：只需要处理两个数据源就可以（上部&amp;下部），视图由UICollectionView自己处理，包括动画效果也是系统自己完成； 缺点：基于UICollectionView，功能的拓展受到一定的限制，动画不如方式一看这舒服。 我的完善：原框架功能较少（相对于今日头条的channel编辑效果），只有上部分的排序和删除。（下部及其他功能已添加） GIF效果图： 其他功能 标题内容对应滑动，滑动后标题居中 标题随滑动，字体大小变化 子视图内，有颜色渐变小Demo GIF效果图： QQ Popover弹框效果GIF效果图： Demo下载","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"UICollectionView下拉刷新闪一下问题解决","slug":"UICollectionView下拉刷新闪一下问题解决","date":"2017-10-12T07:31:08.000Z","updated":"2018-04-14T00:36:27.327Z","comments":true,"path":"2017/10/12/UICollectionView下拉刷新闪一下问题解决/","link":"","permalink":"http://blogzhou.top/2017/10/12/UICollectionView下拉刷新闪一下问题解决/","excerpt":"","text":"最近写项目遇到UICollectionView的下拉刷新数据回来时，屏幕会闪一下，在网上找了几个方法，亲自试了都不好使，后来自己试了下回主线程刷新UI，发现可以，代码如下:123dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView reloadData]; &#125;); 大家都知道，在子线程刷新UI是很危险的，有时会出现莫名的Bug, 有些情况甚至会直接崩溃。而网络数据的请求一般都是在子线程进行的，数据回来时去刷新UI（UITableView 和 UIConllectionView）但是UITableView在子线程刷新UI没有出现这个Bug（估计苹果做了优化）。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"WYYKTScroll控件悬停","slug":"WYYKTScroll控件悬停","date":"2017-10-12T07:25:30.000Z","updated":"2018-04-14T00:36:27.328Z","comments":true,"path":"2017/10/12/WYYKTScroll控件悬停/","link":"","permalink":"http://blogzhou.top/2017/10/12/WYYKTScroll控件悬停/","excerpt":"效果示例 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果","text":"效果示例 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果 1.工程引入FMBaseViewController, 并添加要自定义的controller 有关头部image及button的相关设置通过，FMBaseViewController的属性进行设置，示例代码如下：123456789FMBaseViewController *bvc = [[FMBaseViewController alloc] init];bvc.btnBackColor = [UIColor cyanColor];bvc.btnTitleArr = @[@&quot;张三&quot;, @&quot;李四&quot;, @&quot;王五&quot;];bvc.indicatorColor = [UIColor yellowColor];bvc.isIndicatorHidden = YES;bvc.headImage_H = 100;bvc.button_H = 30;bvc.headImageName = @&quot;picture_3&quot;;bvc.isStretch = NO; 2.注意：自定义的controller 必须继承于FMParentViewController.h, 并且子控制器暂时只支持UITableViewController 子控制器类型1 ：FMTableViewStylePlain 初始化代码如下： 123FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStylePlain];或者（default）FMT1ViewController *t1 = [[FMT1ViewController alloc] init]; 子控制器类型2：FMTableViewStyleGroup 初始化代码如下： 1234FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];或者（用属性修改）FMT1ViewController *t2 = [[FMT1ViewController alloc] init];t2.tableViewStyle = FMTableViewStyleGrouped; 3.头部视图是否可以拉伸： 1isStretch 属性（default is YES） 测试效果查看，在AppDelegate.m 的launch函数中添加（或替换）如下代码： 123FMBaseViewController *bvc = [[FMBaseViewController alloc] init]; self.window.rootViewController = bvc; [self.window makeKeyAndVisible]; 自定义子controller初始化后传入该数组childVCArr，示例代码如下： 12345FMBaseViewController *bvc = [[FMBaseViewController alloc] init];FMT1ViewController *t1 = [[FMT1ViewController alloc] init];FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];FMT3ViewController *t3= [[FMT3ViewController alloc] init];bvc.childVCArr = @[t1, t2, t3]; ####子控制器最好不要超过5个， 暂不支持滑动（以后可能添加，敬请期待！） headView上的内容可自定义添加，通过 ftc.headView可拿到head部分的视图添加自己的控件。 支持cocoaPods 安装 1234pod search WYTest在Podfile中添加pod &quot;WYTest&quot;pod install || pod update ##github Demo下载地址点击去下载","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"如何利用pod trunk发布程序","slug":"如何使项目支持cocoaPods","date":"2017-10-11T06:16:01.000Z","updated":"2018-04-14T00:36:27.328Z","comments":true,"path":"2017/10/11/如何使项目支持cocoaPods/","link":"","permalink":"http://blogzhou.top/2017/10/11/如何使项目支持cocoaPods/","excerpt":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息","text":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: MJ Lee- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec create 文件名 比如pod spec cretae MJExtension就会生成一个MJExtension.podspec 填写podspec内容1234567891011121314Pod::Spec.new do |s| s.name = &quot;MJExtension&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/CoderMJLee/MJExtension&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;MJLee&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/CoderMJLee/MJExtension.git&quot;, :tag =&gt; s.version &#125; s.frameworks = &quot;UIKit&quot;, &quot;Foundation&quot; s.platform = :ios, &quot;8.0&quot; s.source_files = &quot;MJExtensionExample/MJExtensionExample/MJExtension&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint MJExtension.podspec 发布podspec pod trunk push MJExtension.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.gitpodspec 更新版本步骤 1.代码修改 2.修改podspec文件中的version 版本号 3.git tag (后跟版本号)&amp; git push —-tags同步远程仓库版本号 4.将本地的代码提交远程仓库（更新版本号） 5.pod trunk push xxx.podspec 提交最新的podspec文件 注意：提交的代码里最好不要有警告","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://blogzhou.top/tags/tool/"}]}]}