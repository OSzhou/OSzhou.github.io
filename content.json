{"meta":{"title":"Fighting","subtitle":"记二三事而已","description":"The biggest adventure you can take is to live the life of your dreams","author":"Zhouheng","url":"http://blogzhou.top"},"pages":[{"title":"OC/Swift混编的一些小知识","date":"2020-12-15T05:31:57.000Z","updated":"2020-12-15T05:43:57.668Z","comments":true,"path":"template.html","permalink":"http://blogzhou.top/template.html","excerpt":"","text":""},{"title":"About","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"about/index.html","permalink":"http://blogzhou.top/about/index.html","excerpt":"","text":"I am what I am, 我永远都爱这样的我。 免责声明: 鄙人在此发文，记二三事而已，少许借鉴，皆注明出处，如版权归属者存有异议，还请告知。文皆随意敲击键盘所出，用以检验本人电脑键盘录入、屏幕显示、鼠标定位性能，非吾志也。 email：fm939071955@163.com Music Oops Now I have come to the crossroads in my life.I always knew what the right path was.Without exception,I knew,but I never took it.You know why?It was too damn hard!"},{"title":"Categories","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"categories/index.html","permalink":"http://blogzhou.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-14T00:36:27.330Z","updated":"2018-04-14T00:36:27.330Z","comments":true,"path":"tags/index.html","permalink":"http://blogzhou.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Array的常见操作","slug":"s13.Array的常见操作","date":"2020-11-20T04:31:57.000Z","updated":"2020-12-15T05:53:38.391Z","comments":true,"path":"2020/11/20/s13.Array的常见操作/","link":"","permalink":"http://blogzhou.top/2020/11/20/s13.Array的常见操作/","excerpt":"map / filter / reduce 12345678var arr = [1, 2, 3, 4]// [2, 4, 6, 8]var arr2 = arr.map &#123; $0 * 2 &#125;// [2, 4]var arr3 = arr.filter &#123; $0 % 2 == 0 &#125; // 10var arr4 = arr.reduce(0) &#123; $0 + $1 &#125; // 10// 可简写为var arr5 = arr.reduce(0, +) map接收函数作为参数 1234func double(_ i: Int) -&gt; Int &#123; i * 2 &#125; var arr = [1, 2, 3, 4]// [2, 4, 6, 8] print(arr.map(double))","text":"map / filter / reduce 12345678var arr = [1, 2, 3, 4]// [2, 4, 6, 8]var arr2 = arr.map &#123; $0 * 2 &#125;// [2, 4]var arr3 = arr.filter &#123; $0 % 2 == 0 &#125; // 10var arr4 = arr.reduce(0) &#123; $0 + $1 &#125; // 10// 可简写为var arr5 = arr.reduce(0, +) map接收函数作为参数 1234func double(_ i: Int) -&gt; Int &#123; i * 2 &#125; var arr = [1, 2, 3, 4]// [2, 4, 6, 8] print(arr.map(double)) compactMap默认解包并去除nil 1234567var arr = [&quot;123&quot;, &quot;test&quot;, &quot;jack&quot;, &quot;-30&quot;] // [Optional(123), nil, nil, Optional(-30)] var arr2 = arr.map &#123; Int($0) &#125;// [123, -30]var arr3 = arr.compactMap &#123; Int($0) &#125; 使用reduce实现map、filter函数的功能 1234567891011var arr = [1, 2, 3, 4]// [2, 4, 6, 8]print(arr.map &#123; $0 * 2 &#125;) // 等价于👆函数功能print(arr.reduce([]) &#123; $0 + [$1 * 2] &#125;)// [2, 4]print(arr.filter &#123; $0 % 2 == 0 &#125;) // 等价于👆函数功能print(arr.reduce([]) &#123; $1 % 2 == 0 ? $0 + [$1] : $0 &#125;) map,flatMap功能对比 12345var arr = [1, 2, 3]// [[1], [2, 2], [3, 3, 3]] 拿到什么(数组)，返回数组(二维数组)就放什么，不做处理。var arr2 = arr.map &#123; Array.init(repeating: $0, count: $0) &#125;// [1, 2, 2, 3, 3, 3] 将拿到的数组中的元素取出放到返回数组(一维数组)中。扁平化处理。var arr3 = arr.flatMap &#123; Array.init(repeating: $0, count: $0) &#125; 用lazy的优化map 1234567891011121314151617181920let arr = [1, 2, 3]let result = arr.lazy.map &#123; (i: Int) -&gt; Int in print(&quot;mapping \\(i)&quot;) return i * 2&#125;print(&quot;begin-----&quot;)print(&quot;mapped&quot;, result[0]) print(&quot;mapped&quot;, result[1]) print(&quot;mapped&quot;, result[2]) print(&quot;end----&quot;)// 第一次用到时，才会执行相应逻辑begin----- mapping 1 mapped 2 mapping 2 mapped 4 mapping 3 mapped 6 end---- map和flatMap可选值Optional处理中的应用 1234567var num1: Int? = 10// Optional(20)var num2 = num1.map &#123; $0 * 2 &#125;var num3: Int? = nil// nil，发现$0为nil直接返回nilvar num4 = num3.map &#123; $0 * 2 &#125; map 和 flatMap对比123456var num1: Int? = 10// Optional(Optional(20)), map还是会对可选值再包装一层var num2 = num1.map &#123; Optional.some($0 * 2) &#125;// Optional(20), flatMap发现已经是可选值，就不会再包装了var num3 = num1.flatMap &#123; Optional.some($0 * 2) &#125; 可用于简化代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 示例一：var num1: Int? = 10var num2 = (num1 != nil) ? (num1! + 10) : nil var num3 = num1.map &#123; $0 + 10 &#125;// num2、num3是等价的// 示例二：var fmt = DateFormatter()fmt.dateFormat = &quot;yyyy-MM-dd&quot;var str: String? = &quot;2011-09-10&quot;// oldvar date1 = str != nil ? fmt.date(from: str!) : nil // newvar date2 = str.flatMap(fmt.date)// 示例三：var score: Int? = 98// oldvar str1 = score != nil ? &quot;socre is \\(score!)&quot; : &quot;No score&quot; // newvar str2 = score.map &#123; &quot;score is \\($0)&quot; &#125; ?? &quot;No score&quot;// 示例四：struct Person &#123; var name: String var age: Int&#125;var items = [ Person(name: &quot;jack&quot;, age: 20), Person(name: &quot;rose&quot;, age: 21), Person(name: &quot;kate&quot;, age: 22)]// oldfunc getPerson1(_ name: String) -&gt; Person? &#123; let index = items.firstIndex &#123; $0.name == name &#125; return index != nil ? items[index!] : nil&#125;// newfunc getPerson2(_ name: String) -&gt; Person? &#123; return items.firstIndex &#123; $0.name == name &#125;.map &#123; items[$0] &#125;&#125;// 示例五：struct Person &#123; var name: String var age: Int init?(_ json: [String : Any]) &#123; guard let name = json[&quot;name&quot;] as? String, let age = json[&quot;age&quot;] as? Int else &#123; return nil &#125; self.name = name self.age = age &#125; &#125;var json: Dictionary? = [&quot;name&quot; : &quot;Jack&quot;, &quot;age&quot; : 10] // oldvar p1 = json != nil ? Person(json!) : nil// newvar p2 = json.flatMap(Person.init)","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://blogzhou.top/tags/Swift/"}]},{"title":"Swift中的指针(UnsafePointer)","slug":"s12.Swift中的指针(UnsafePointer)","date":"2020-11-18T01:31:57.000Z","updated":"2020-12-16T06:15:23.694Z","comments":true,"path":"2020/11/18/s12.Swift中的指针(UnsafePointer)/","link":"","permalink":"http://blogzhou.top/2020/11/18/s12.Swift中的指针(UnsafePointer)/","excerpt":"Swift中也有专门的指针类型，这些都被定性为“Unsafe”(不安全的)。常见的有以下4种类型： UnsafePointer&lt;Pointee&gt;类似于 const Pointee * UnsafeMutablePointer&lt;Pointee&gt; 类似于 Pointee * UnsafeRawPointer 类似于 const void * UnsafeMutableRawPointer 类似于 void *123456789101112131415161718192021var age = 10func test1(_ ptr: UnsafeMutablePointer&lt;Int&gt;) &#123; ptr.pointee += 10 &#125;func test2(_ ptr: UnsafePointer&lt;Int&gt;) &#123; print(ptr.pointee)&#125;test1(&amp;age)test2(&amp;age) // 20print(age) // 20var age = 10func test3(_ ptr: UnsafeMutableRawPointer) &#123; ptr.storeBytes(of: 20, as: Int.self) &#125;func test4(_ ptr: UnsafeRawPointer) &#123; print(ptr.load(as: Int.self))&#125;test3(&amp;age)test4(&amp;age) // 20print(age) // 20","text":"Swift中也有专门的指针类型，这些都被定性为“Unsafe”(不安全的)。常见的有以下4种类型： UnsafePointer&lt;Pointee&gt;类似于 const Pointee * UnsafeMutablePointer&lt;Pointee&gt; 类似于 Pointee * UnsafeRawPointer 类似于 const void * UnsafeMutableRawPointer 类似于 void *123456789101112131415161718192021var age = 10func test1(_ ptr: UnsafeMutablePointer&lt;Int&gt;) &#123; ptr.pointee += 10 &#125;func test2(_ ptr: UnsafePointer&lt;Int&gt;) &#123; print(ptr.pointee)&#125;test1(&amp;age)test2(&amp;age) // 20print(age) // 20var age = 10func test3(_ ptr: UnsafeMutableRawPointer) &#123; ptr.storeBytes(of: 20, as: Int.self) &#125;func test4(_ ptr: UnsafeRawPointer) &#123; print(ptr.load(as: Int.self))&#125;test3(&amp;age)test4(&amp;age) // 20print(age) // 20 获得指向某个变量的指针: 123456789101112var age = 11var ptr1 = withUnsafeMutablePointer(to: &amp;age) &#123; $0 &#125; var ptr2 = withUnsafePointer(to: &amp;age) &#123; $0 &#125; ptr1.pointee = 22print(ptr2.pointee) // 22print(age) // 22var ptr3 = withUnsafeMutablePointer(to: &amp;age) &#123; UnsafeMutableRawPointer($0) &#125; var ptr4 = withUnsafePointer(to: &amp;age) &#123; UnsafeRawPointer($0) &#125; ptr3.storeBytes(of: 33, as: Int.self)print(ptr4.load(as: Int.self)) // 33print(age) // 33 获得指向堆空间实例的指针： 1234567891011// UnsafeRawPointer(bitPattern:)函数用来生成指向某一地址的指针var ptr = UnsafeRawPointer(bitPattern: 0x100001234)class Person &#123;&#125;// 类似于 *p = personvar person = Person()// p = &amp;person， p是person变量的地址值var ptr = withUnsafePointer(to: &amp;person) &#123; UnsafeRawPointer($0) &#125;// ptr.load(as: UInt.self) 类似于 *p， 取出地址中存储的值，也就是Person实例在堆上的地址值var heapPtr = UnsafeRawPointer(bitPattern: ptr.load(as: UInt.self)) print(heapPtr!) 创建指针： 非泛型 1234567891011121314151617181920 // 创建var ptr = malloc(16)// 存ptr?.storeBytes(of: 11, as: Int.self)ptr?.storeBytes(of: 22, toByteOffset: 8, as: Int.self)// 取print((ptr?.load(as: Int.self))!) // 11 // fromByteOffset: 地址偏移print((ptr?.load(fromByteOffset: 8, as: Int.self))!) // 22 // 销毁free(ptr)var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) ptr.storeBytes(of: 11, as: Int.self)// advanced: 也是地址偏移ptr.advanced(by: 8).storeBytes(of: 22, as: Int.self) print(ptr.load(as: Int.self)) // 11print(ptr.advanced(by: 8).load(as: Int.self)) // 22 // 销毁ptr.deallocate() 泛型基础数据类型： 123456789101112131415 var ptr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 3) ptr.initialize(to: 11)// successor()后继, 表示向后走&lt;Int&gt;长度个字节ptr.successor().initialize(to: 22) ptr.successor().successor().initialize(to: 33)print(ptr.pointee) // 11 // 这里的 + 指的是指针的加，步长为&lt;Int&gt;长度个字节print((ptr + 1).pointee) // 22 print((ptr + 2).pointee) // 33print(ptr[0]) // 11print(ptr[1]) // 22print(ptr[2]) // 33ptr.deinitialize(count: 3) ptr.deallocate() 对象类型： 123456789101112131415161718 class Person &#123; var age: Int var name: String init(age: Int, name: String) &#123; self.age = age self.name = name &#125; deinit &#123; print(name, &quot;deinit&quot;) &#125; &#125;var ptr = UnsafeMutablePointer&lt;Person&gt;.allocate(capacity: 3) ptr.initialize(to: Person(age: 10, name: &quot;Jack&quot;))(ptr + 1).initialize(to: Person(age: 11, name: &quot;Rose&quot;)) (ptr + 2).initialize(to: Person(age: 12, name: &quot;Kate&quot;))// Jack deinit// Rose deinit// Kate deinit ptr.deinitialize(count: 3) ptr.deallocate() 指针之间的转换 1234567891011121314151617 var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) ptr.assumingMemoryBound(to: Int.self).pointee = 11(ptr + 8).assumingMemoryBound(to: Double.self).pointee = 22.0 // 只改变类型，而不改变其值 //（值指的是二进制数据，也就是你告诉计算机这是什么类型，计算机就按什么类型解读这些二进制数据）print(unsafeBitCast(ptr, to: UnsafePointer&lt;Int&gt;.self).pointee) // 11print(unsafeBitCast(ptr + 8, to: UnsafePointer&lt;Double&gt;.self).pointee) // 22.0 ptr.deallocate()// unsafeBitCast是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据 // 类似于C++中的reinterpret_castclass Person &#123;&#125;var person = Person()var ptr = unsafeBitCast(person, to: UnsafeRawPointer.self) print(ptr) 关于指针的强制类型转换可参考这篇","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://blogzhou.top/tags/Swift/"}]},{"title":"关于指针的强制类型转换","slug":"s11.关于指针的强制类型转换","date":"2020-11-15T05:45:57.000Z","updated":"2020-12-15T05:48:31.067Z","comments":true,"path":"2020/11/15/s11.关于指针的强制类型转换/","link":"","permalink":"http://blogzhou.top/2020/11/15/s11.关于指针的强制类型转换/","excerpt":"","text":"将指针从一种类型强制转换成另一种类型，只改变他的类型，而不改变他的值。 强制类型转换的一个效果是改变指针运算的伸缩。例如：如果p是个char 类型的指针，他的值为P，那么表达式`(int )p + 7 = P + 28因为int占4字节，而char只占1字节 而:(int )(p + 7) = P + 7`因为，强制类型转换的优先级高于加法。**PS:**指针+i，表示加i个单元格，即加`i sizeof(指针本身去掉一个*)`的字节：1(int *)p + 7 = P + 7 * sizeof(int) = P + 28","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"code","slug":"code","permalink":"http://blogzhou.top/tags/code/"}]},{"title":"App启动优化","slug":"old_02.App启动优化","date":"2020-06-25T02:31:30.000Z","updated":"2020-12-16T06:19:20.446Z","comments":true,"path":"2020/06/25/old_02.App启动优化/","link":"","permalink":"http://blogzhou.top/2020/06/25/old_02.App启动优化/","excerpt":"一、冷启动和热启动 定义： 1.关于冷启动：业界对冷启动的定义没有问题，普遍认为是手机开机后第一次启动某个APP。 2.关于热启动： 对热启动有两种不同的看法： 1.有些人认为是按下home键把APP挂到后台，之后点击APP的icon再拉回来到前台算是热启动； 2.也有些人认为是手机开机后在短时间内第二次启动APP（杀掉进程重启）算是热启动（此时dyld会对部分APP的数据和库进行缓存，所以比第一次启动要快）。 （一般认为APP从后台拉起到前台的时间没啥研究的意义，所以在统计启动时间时，会倾向于后一种说法，不过具体怎么定义看个人，知道其中的区别就好） 如果启动过，内存页就已经加载进内存了，内存页如果要销毁只能是被覆盖，所以这时候的加载进物理内存的时候，实际内存中已经存在值，所以启动就会变快。","text":"一、冷启动和热启动 定义： 1.关于冷启动：业界对冷启动的定义没有问题，普遍认为是手机开机后第一次启动某个APP。 2.关于热启动： 对热启动有两种不同的看法： 1.有些人认为是按下home键把APP挂到后台，之后点击APP的icon再拉回来到前台算是热启动； 2.也有些人认为是手机开机后在短时间内第二次启动APP（杀掉进程重启）算是热启动（此时dyld会对部分APP的数据和库进行缓存，所以比第一次启动要快）。 （一般认为APP从后台拉起到前台的时间没啥研究的意义，所以在统计启动时间时，会倾向于后一种说法，不过具体怎么定义看个人，知道其中的区别就好） 如果启动过，内存页就已经加载进内存了，内存页如果要销毁只能是被覆盖，所以这时候的加载进物理内存的时候，实际内存中已经存在值，所以启动就会变快。 二、优化的方向1.减少流程的数量。2.减少每个流程的消耗。 三、APP的启动过程 四、启动时间分布在Xcode中，可以通过设置环境变量来查看App的启动时间，DYLD_PRINT_STATISTICS和DYLD_PRINT_STATISTICS_DETAILS。根据xcode打印可以看到:动态库的加载 rebase/binding 方法、类、Category这些需要rebase和 binding binding Mach-O _DATA建立指针，指向外部函数，我们编译的时候，共享缓存库里边的代码指向的就是这里，链接的时候，通过dyld指向外部具体真实的地址。PIC技术fishook就是利用这个中转，hook的系统c函数。 Objc setup 类的初始化过程在这里边①读取二进制文件的 DATA 段内容，找到与 objc 相关的信息②注册 Objc 类，ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中；③读取 protocol 以及 category 的信息，把category的定义插入方法列表 (category registration)，④确保 selector 的唯一性 initializer load等函数，C++的构造函数 耗时比较多的加载自己的库可能比较耗时 两个阶段分别是 pre- main 和 main启动到viewDidAppear:pre-main过程：什么是dyld? dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 五、 Dyld加载过程加载Mach-O文件，加载一块比较大的内存空间，地址重定向启动dyld的main函数 配置xcode的环境变量 (arguments) 加载共享缓存库，UIKit 和 Foundation这些 加载LoadCommons段一系列加载加载动态库，包括自己的和系统的，实例化主程序的imageLoader，添加进imageList链接主程序 开始初始化主程序 runtime配合加载，runtime加载loadImages方法，这个方法就是prepare_load_methods(mh) 加载load和C++构造函数找main函数配置（环境变量） — 加载（共享动态库，主程序，动态库） — 链接（链接主程序，动态库） — 初始化（程序） 加载动态库过程，动态链接器dyld需要做如下操作1.分析依赖的动态库2.找到动态库的Mach-O文件3.打开文件4.验证文件5.在系统的内核注册文件签名6.对动态库的每个segment调用mmap() 针对这一步优化 1.减少非系统的动态库2.使用静态库而不是动态库3.合并非系统的动态库为一个 1.动态库尽可能少，不要多与6个，如果多了，尽可能合并2.20000个类 800毫秒3.swift静态语言，性能更高 六、ObjC SetUp由于之前2步骤的优化，这一步实际上没有什么可做的。几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。 七、Initializers 以上三步属于静态调整，都是在修改__DATA segment中的内容现在开始动态调整，在堆和栈中写入内容。 工作主要有：1、Objc的+load()函数2、C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()3、非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度可以做的优化有：①使用 +initialize 来替代 +load②不要使用 atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。 比如使用 dispatch_once(),pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时。 也尽量不要用到C++的静态对象。 从效率上来说，在+load 和+initialize里执行同样的代码，效率是一样的，即使有差距，也不会差距太大。 但所有的+load方法都在启动的时候调用，方法多了就会严重影响启动速度了。 就说我们项目中，有200个左右+load方法，一共耗时大概1s 左右，这块就会严重影响到用户感知了。 而+initialize方法是在对应 Class 第一次使用的时候调用，这是一个懒加载的方法，理想情况下，这200个+load方法都使用+initialize来代替，将耗时分摊到用户使用过程中，每个方法平均耗时只有5ms，用户完全可以无感知。 #####八、二进制重排iOS的虚拟内存和物理内存：之前所有应用都加载进内存条中，会有安全问题，会访问到其他人的软件中去 iOS虚拟内存有4G的 CPU通过 操作系统映射表 映射虚拟内存和物理真实内存也就是我们访问虚拟内存，都会走到映射表，然后映射到真实的物理内存。（每个映虚拟内存对应一个映射表）（mmp）分页加载，提高内存的利用率内存是以字节为单位，内存以页管理 PAGE，Linux每1页4KB，iOS每一页16KB 用这种分页加载，用到哪块内存就加载到真实内存上述P2加载的时候，发现真实内存没有，缺页，CPU会临时加载 如果启动的时候缺页比较多（缺页异常），就会不断去映射到物理内存，就会卡顿iOS的内存地址，与编译顺序有关，所以如果方法在不同的类，类的加载差距比较大，那么就会加载比较多的页，就会浪费时间。iOS系统还会对加载的每一页做签名认证，所以更加消耗时间。 system traceMain ThreadVirtual Memory File Backard Page In ldydorder_file 自己写一个文件，里边指定方法的顺序，可以将启动要调用的方法，都放到里边。libc-order在objc源码里边，这就是二进制重排 所有OC方法获取用fishhook 去 HOOK objc_msgSend()方法，可以拿到所有的函数可以用Clang插庒的方式AOP 八、main过程： Main函数之后 1.懒加载2.发挥CPU的价值，用多线程的方式。3.框架的搭建尽量避免stroyboard 和 xib 分阶段加载： 在didFinishLunch中启动的： 埋点功能、 Crash 采集 网络配置等 在首页viewDidappear 初始化SDK，友盟SDK、人脸识别SDK后移 开始定位（显示定位中），定位可以缓存，先加载，定位同步进行，如果缓存的地理位置不一样，然后才更新 配置下发等 多线程启动 尝试使用多线程启动将数据库的配置、SDwebimage UA的配置放到子线程中初始化，引入状态管理，需要监控子线程任务状态，判断是否取消假的开屏页面。 广告同步加载，2秒回来了就展示，不回来就过Timer Profile的使用)","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://blogzhou.top/tags/OC/"}]},{"title":"Swift 小记","slug":"s14.Swift 小记","date":"2019-12-25T02:31:30.000Z","updated":"2020-12-16T06:19:09.305Z","comments":true,"path":"2019/12/25/s14.Swift 小记/","link":"","permalink":"http://blogzhou.top/2019/12/25/s14.Swift 小记/","excerpt":"往日里项目太赶，虽断断续续跟了仨Swift项目，但有些东西始终停留在会用的层面上，知其然，而不知其所以然。刚好当下无事，5.0之后ABI也基本稳定，便想着好好梳理一番。声明如下：文章内容皆随心随性所记，旨在提点检索记忆中所存对应知识所用，对他人的助益可能微乎其微。若不小心点击进入，并因此浪费你宝贵的时间，实在是抱歉。若你因此心情不爽，那就在评论区骂我两句，以排解心中愤懑。我保证秉承 公平 公正 公开的原则怼回去。 1. Playground支持Markup(类似Markdown)语言书写注释。 //: [上一页](@previous): 上一页 //: [下一页](@next): 下一页 #：几个对应几级标题 -：无序标题 1.：有序标题 &gt;：笔记 ---：分割线 [图片上传失败...(image-16af49-1606451751395)]：图片 [blog](http://blogzhou.top)：连接 ** bold **：粗体 * italic *：斜体","text":"往日里项目太赶，虽断断续续跟了仨Swift项目，但有些东西始终停留在会用的层面上，知其然，而不知其所以然。刚好当下无事，5.0之后ABI也基本稳定，便想着好好梳理一番。声明如下：文章内容皆随心随性所记，旨在提点检索记忆中所存对应知识所用，对他人的助益可能微乎其微。若不小心点击进入，并因此浪费你宝贵的时间，实在是抱歉。若你因此心情不爽，那就在评论区骂我两句，以排解心中愤懑。我保证秉承 公平 公正 公开的原则怼回去。 1. Playground支持Markup(类似Markdown)语言书写注释。 //: [上一页](@previous): 上一页 //: [下一页](@next): 下一页 #：几个对应几级标题 -：无序标题 1.：有序标题 &gt;：笔记 ---：分割线 [图片上传失败...(image-16af49-1606451751395)]：图片 [blog](http://blogzhou.top)：连接 ** bold **：粗体 * italic *：斜体 2. Let :不要求在编译时确定，但使用前必须赋值。也就是实例初始化前必须有值，(存储类型属性除外)123// 下面代码错误，因声明时未指明常量类型let ageage = 18 #####3. 可变参数 public func print(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\\n&quot;)：形如 Any… 为可变参数 #####4. 函数可作为参数和返回值。 123456789101112131415161718192021222324252627282930// 作为参数func sum(v1: Int, v2: Int) -&gt; Int &#123; v1 + v2&#125;func difference(v1: Int, v2: Int) -&gt; Int &#123; v1 - v2&#125;func printResult(_ mathFn: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(&quot;Result: \\(mathFn(a, b))&quot;)&#125;printResult(sum, 5, 2) // Result: 7printResult(difference, 5, 2) // Result: 3----------------------------------------------------------------------------------------------------------// 作为返回值func next(_ input: Int) -&gt; Int &#123; input + 1&#125;func previous(_ input: Int) -&gt; Int &#123; input - 1 &#125;func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123; forward ? next : previous&#125;forward(true)(3) // 4forward(false)(3) // 2n返回值是函数类型的函数，叫做高阶函数(Higher-Order Function) 5. 方法123456789101112// 嵌套函数。 func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123; func next(_ input: Int) -&gt; Int &#123; input + 1 &#125; func previous(_ input: Int) -&gt; Int &#123; input - 1 &#125; return forward ? next : previous&#125;forward(true)(3) // 4forward(false)(3) // 2 将方法赋值给var\\let方法也可以像函数那样，赋值给一个let或者var 12345678910111213struct Person &#123; var age: Int func run(_ v: Int) &#123; print(&quot;func run&quot;, age, v) &#125; static func run(_ v: Int) &#123; print(&quot;static func run&quot;, v) &#125; &#125;let fn1 = Person.runfn1(10) // static func run 10let fn2: (Int) -&gt; () = Person.run fn2(20) // static func run 20let fn3: (Person) -&gt; ((Int) -&gt; ()) = Person.run fn3(Person(age: 18))(30) // func run 18 30 6. 枚举。 关联值(Associated Values) 有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用1234567891011121314enum Score &#123; case points(Int) case grade(Character)&#125;var score = Score.points(96) score = .grade(&quot;A&quot;)switch score &#123; case let .points(i): print(i, &quot;points&quot;) case let .grade(i): print(&quot;grade&quot;, i)&#125; // grade A 递归枚举： 1234567891011121314151617181920212223242526272829// indirect修饰indirect enum ArithExpr &#123; case number(Int) case sum(ArithExpr, ArithExpr) case difference(ArithExpr, ArithExpr)&#125;enum ArithExpr &#123; case number(Int) indirect case sum(ArithExpr, ArithExpr) indirect case difference(ArithExpr, ArithExpr)&#125;let five = ArithExpr.number(5)let four = ArithExpr.number(4)let two = ArithExpr.number(2)let sum = ArithExpr.sum(five, four)let difference = ArithExpr.difference(sum, two)func calculate(_ expr: ArithExpr) -&gt; Int &#123; switch expr &#123; case let .number(value): return value case let .sum(left, right): return calculate(left) + calculate(right) case let .difference(left, right): return calculate(left) - calculate(right) &#125; &#125;calculate(difference) 7. 可以使用MemoryLayout获取数据类型占用的内存大小1234567891011121314enum Password &#123; case number(Int, Int, Int, Int) case other&#125; MemoryLayout&lt;Password&gt;.stride // 40, 分配占用的空间大小 MemoryLayout&lt;Password&gt;.size // 33, 实际用到的空间大小 MemoryLayout&lt;Password&gt;.alignment // 8, 对齐参数var pwd = Password.number(9, 8, 6, 4)pwd = .other MemoryLayout.stride(ofValue: pwd) // 40 MemoryLayout.size(ofValue: pwd) // 33MemoryLayout.alignment(ofValue: pwd) // 8 8. 可选项(Optional)1234567891011121314151617// n 可选项，一般也叫可选类型，它允许将值设置为nil // n在类型名称后面加个问号? 来定义一个可选项var name: String? = &quot;Jack&quot;name = nilvar age: Int? // 默认就是nil age = 10age = nilvar array = [1, 15, 40, 29] func get(_ index: Int) -&gt; Int? &#123; if index &lt; 0 || index &gt;= array.count &#123; return nil &#125; return array[index]&#125; print(get(1)) // Optional(15)print(get(-1)) // nil print(get(4)) // nil 可选项是对其他类型的一层包装，可以将它理解为一个盒子 如果为nil，那么它是个空盒子 如果不为nil，那么盒子里装的是:被包装类型的数据 如果要从可选项中取出被包装的数据(将盒子里装的东西取出来)，需要使用感叹号! 进行强制解包 如果对值为nil的可选项(空盒子)进行强制解包，将会产生运行时错误var age: Int?age!Fatal error: Unexpectedly found nil while unwrapping an Optional value 多重可选项12345var num1: Int? = 10var num2: Int?? = num1var num3: Int?? = 10 print(num2 == num3) // true 1234567var num1: Int? = nilvar num2: Int?? = num1var num3: Int?? = nil// num2中装的是个可选类型，num3中装的是nil，所以不相等。print(num2 == num3) // false(num2 ?? 1) ?? 2 // 2(num3 ?? 1) ?? 2 // 1 9. 空合并运算符 ??(Nil-Coalescing Operator)123public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T?) rethrows -&gt; T?public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T a ?? ba 是可选项b 是可选项 或者 不是可选项b 跟 a 的存储类型必须相同如果 a 不为nil，就返回 a如果 a 为nil，就返回 b如果 b 不是可选项，返回 a 时会自动解包 #####10. 类 和 结构体 类：引用类型，内存在堆上，默认只有一个无参的初始化器（定义成员时指定了初始化值，否则一个没有）。 结构体：值类型，内存根据代码定义的地方不同而不同，默认有好多个初始化器。 #####11. 闭包表达式(Closure Expression) ：一种函数的定义方式 在Swift中，可以通过func定义一个函数，也可以通过闭包表达式定义一个函数12345678910111213141516func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;var fn = &#123;(v1: Int, v2: Int) -&gt; Int in return v1 + v2&#125;fn(10, 20)&#123;(v1: Int, v2: Int) -&gt; Int in return v1 + v2&#125;(10, 20)&#123;(参数列表) -&gt; 返回值类型 in 函数体代码&#125; 12. 闭包 一个函数和它所捕获的变量\\常量环境组合起来，称为闭包 一般指定义在函数内部的函数 一般它捕获的是外层函数的局部变量\\常量123456789typealias Fn = (Int) -&gt; Int func getFn() -&gt; Fn &#123; var num = 0 func plus(_ i: Int) -&gt; Int &#123; num += i return num &#125; return plus&#125; // 返回的plus和num形成了闭包 辅助理解： 可以把闭包想象成是一个类的实例对象 内存在堆空间 捕获的局部变量\\常量就是对象的成员(存储属性) 组成闭包的函数就是类内部定义的方法123456class Closure &#123; var num = 0 func plus(_ i: Int) -&gt; Int &#123; num += i return num &#125;&#125; 13. 自动闭包@autoclosure12345678910111213141516// 如果第1个数大于0，返回第一个数。否则返回第2个数func getFirstPositive(_ v1: Int, _ v2: Int) -&gt; Int &#123; return v1 &gt; 0 ? v1 : v2&#125;getFirstPositive(10, 20) // 10 getFirstPositive(-2, 20) // 20 getFirstPositive(0, -4) // -4// 改成函数类型的参数，可以让v2延迟加载func getFirstPositive(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123; return v1 &gt; 0 ? v1 : v2() &#125;getFirstPositive(-4) &#123; 20 &#125;func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -&gt; Int) -&gt; Int? &#123; return v1 &gt; 0 ? v1 : v2()&#125;getFirstPositive(-4, 20) @autoclosure 会自动将 20 封装成闭包 { 20 } @autoclosure 只支持 () -&gt; T 格式的参数 @autoclosure 并非只支持最后1个参数 空合并运算符 ?? 使用了 @autoclosure 技术 有@autoclosure、无@autoclosure，构成了函数重载为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行 14. 属性 存储属性(Stored Property) 类似于成员变量这个概念 存储在实例的内存中 结构体、类可以定义存储属性 枚举不可以定义存储属性 在创建类 或 结构体的实例时，必须为所有的存储属性设置一个合适的初始值 可以在初始化器里为存储属性设置一个初始值 可以分配一个默认的属性值作为属性定义的一部分 延迟存储属性(Lazy Stored Property): 使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化 lazy属性必须是var，不能是let(存储类型属性除外) let必须在实例的初始化方法完成之前就拥有值 如果多条线程同时第一次访问lazy属性 无法保证属性只被初始化1次 当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性, 因为延迟属性初始化时需要改变结构体的内存 计算属性(Computed Property) 本质就是方法(函数) 不占用实例的内存 枚举、结构体、类都可以定义计算属性 set传入的新值默认叫做newValue，也可以自定义 只读计算属性:只有get，没有set(有set，必须有get) 定义计算属性只能用var，不能用let。let代表常量:值是一成不变的 ，而计算属性的值是可能发生变化的(即使是只读计算属性) 枚举原始值rawValue的本质是:只读计算属性 ######类型属性(Type Property): 属性可以分为: 实例属性(Instance Property):只能通过实例去访问 存储实例属性(Stored Instance Property):存储在实例的内存中，每个实例都有1份 计算实例属性(Computed Instance Property) 类型属性(Type Property):只能通过类型去访问 存储类型属性(Stored Type Property):整个程序运行过程中，就只有1份内存(类似于全局变量) 计算类型属性(Computed Type Property) 可以通过static定义类型属性 如果是类，也可以用关键字class ps:类型属性细节 不同于存储实例属性，你必须给存储类型属性设定初始值。 因为类型没有像实例那样的init初始化器来初始化存储属性 存储类型属性默认就是lazy，会在第一次使用的时候才初始化。 就算被多个线程同时访问，保证只会初始化一次。 存储类型属性可以是let 枚举类型也可以定义类型属性(存储类型属性、计算类型属性)12345678910111213// 单例模式public class FileManager &#123; public static let shared = FileManager() private init() &#123; &#125;&#125;public class FileManager &#123; public static let shared = &#123; // .... // .... return FileManager() &#125;() private init() &#123; &#125;&#125; #####15. 属性观察器(Property Observer) 可以为非lazy的var存储属性设置属性观察器 willSet会传递新值，默认叫newValu didSet会传递旧值，默认叫oldValue 在初始化器中设置属性值不会触发willSet和didSet 在属性定义时设置初始值也不会触发willSet和didSet 父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器 属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量身上1234567891011121314struct Circle &#123; var radius: Double &#123; willSet &#123; print(&quot;willSet&quot;, newValue) &#125; didSet &#123; print(&quot;didSet&quot;, oldValue, radius) &#125; &#125; init() &#123; self.radius = 1.0 print(&quot;Circle init!&quot;) &#125;&#125; #####16. inout的本质 如果实参有物理内存地址，且没有设置属性观察器 直接将实参的内存地址传入函数(实参进行引用传递) 如果实参是计算属性 或者 设置了属性观察器 采取了Copy In Copy Out的做法 调用该函数时，先复制实参的值，产生副本【get】 将副本的内存地址传入函数(副本进行引用传递)，在函数内部可以修改副本的值 函数返回后，再将副本的值覆盖实参的值【set】 总结:inout的本质就是引用传递(地址传递) #####17. 方法 mutating结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改。在func关键字前加mutating可以允许这种修改行为 @discardableResult 在func前面加个@discardableResult，可以消除:函数调用后返回值未被使用的警告⚠ #####18. 下标(subscript) 使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本 subscript的语法类似于实例方法、计算属性，本质就是方法(函数) subscript中定义的返回值类型决定了 get方法的返回值类型 set方法中newValue的类型 subscript可以接受多个参数，并且类型任意 subscript可以没有set方法，但必须要有get方法。如果只有get方法，可以省略。 #####19.继承(Inheritance) 值类型(枚举、结构体)不支持继承，只有类支持继承。 没有父类的类，称为:基类 Swift并没有像OC、Java那样的规定:任何类最终都要继承自某个基类 子类可以重写父类的下标、方法、属性，重写必须加上override关键字 重写类型方法、下标：1.被class修饰的类型方法、下标，允许被子类重写2.被static修饰的类型方法、下标，不允许被子类重写 重写属性： 子类可以将父类的属性(存储、计算)重写为计算属性 子类不可以将父类属性重写为存储属性 只能重写var属性，不能重写let属性 重写时，属性名、类型要一致 子类重写后的属性权限 不能小于 父类属性的权限 如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的 如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的 重写类型属性: 被class修饰的计算类型属性，可以被子类重写 被static修饰的类型属性(存储、计算)，不可以被子类重写 属性观察器: 可以在子类中为父类属性(除了只读计算属性、let属性)增加属性观察器 final: 被final修饰的方法、下标、属性，禁止被重写 被final修饰的类，禁止被继承 多态（继承）原理图示： #####20. 初始化器 类、结构体、枚举都可以定义初始化器 类有2种初始化器:指定初始化器(纵向)(designated initializer)、便捷初始化器(横向)(convenience initializer)12345678// 指定初始化器 init(parameters) &#123; statements &#125;// 便捷初始化器convenience init(parameters) &#123; statements &#125; 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器 默认初始化器总是类的指定初始化器类偏向于少量指定初始化器，一个类通常只有一个指定初始化器 初始化器的相互调用规则:指定初始化器必须从它的直系父类调用指定初始化器便捷初始化器必须从相同的类里调用另一个初始化器便捷初始化器最终必须调用一个指定初始化器 #####21. 两段式初始化 Swift在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、 安全检查 两段式初始化： 第1阶段:初始化所有存储属性:1 外层调用指定\\便捷初始化器2 分配内存给实例，但未初始化3 指定初始化器确保当前类定义的存储属性都初始化4 指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链 - ***第2阶段:设置新的存储属性值***: &gt;1 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例 2 初始化器现在能够使用self(访问、修改它的属性，调用它的实例方法等等)3 最终，链中任何便捷初始化器都有机会定制实例以及使用self #####22. 安全检查、重写、自动继承、required 安全检查: 指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成 指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值 便捷初始化器必须先调用同类中的其它初始化器，然后再为任意属性设置新值 初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self 直到第1阶段结束，实例才算完全合法 重写：1.当重写父类的指定初始化器时，必须加上override(即使子类的实现是便捷初始化器)2.如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上override，因为父类的便捷初始化器永远不会通过子类直接调用，因此，严格来说，子类无法重写父类的便捷初始化 自动继承: 1 如果子类没有自定义任何指定初始化器，它会自动继承父类所有的指定初始化器 2 如果子类提供了父类所有指定初始化器的实现(要么通过方式1继承，要么重写) 子类自动继承所有的父类便捷初始化器 3 就算子类添加了更多的便捷初始化器，这些规则仍然适用 4 子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则2的一部分 required:1.用required修饰指定初始化器，表明其所有子类都必须实现该初始化器(通过继承或者重写实现)2.如果子类重写了required初始化器，也必须加上required，不用加override #####23. 可失败初始化器 类、结构体、枚举都可以使用init?定义可失败初始化器123456789101112131415class Person &#123; var name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;1. 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器2. 可以用init!定义隐式解包的可失败初始化器3. 可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包4. 如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行 5. 可以用一个非可失败初始化器重写一个可失败初始化器，但反过来是不行的 #####24. 反初始化器(deinit) deinit叫做反初始化器，类似于C++的析构函数、OC中的dealloc方法 当类的实例对象被释放内存时，就会调用实例对象的deinit方法 12345678class Person &#123; deinit &#123; print(&quot;Person对象销毁了&quot;) &#125;&#125;// deinit不接受任何参数，不能写小括号，不能自行调用 // 父类的deinit能被子类继承// 子类的deinit实现执行完毕后会调用父类的deinit #####25. 可选链(Optional Chaining) 如果可选项为nil，调用方法、下标、属性失败，结果为nil 如果可选项不为nil，调用方法、下标、属性成功，结果会被包装成可选项 如果结果本来就是可选项，不会进行再次包装12345678910111213141516171819202122// 多个?可以链接在一起// 如果链中任何一个节点是nil，那么整个链就会调用失败var dog = person?.dog // Dog?var weight = person?.dog.weight // Int? var price = person?.car?.price // Int?class Person &#123; var name: String = &quot;&quot; var dog: Dog = Dog() var car: Car? = Car() func age() -&gt; Int &#123; 18 &#125; func eat() &#123; print(&quot;Person eat&quot;) &#125; subscript(index: Int) -&gt; Int &#123; index &#125;&#125;var person: Person? = Person()if let _ = person?.eat() &#123; // ()? print(&quot;eat调用成功&quot;)&#125; else &#123; print(&quot;eat调用失败&quot;)&#125; person?.eat()默认没有返回值，也可以写成var p = person?eat()的赋值形式。因为在Swift中函数其实默认返回-&gt; Void， 而Void = ()，也就是空元祖。所以p也就是()?类型 #####26. 协议(Protocol) 协议中的属性： 必须用var定义 实现时权限不得小于协议中定义的权限 static、class： 为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标 给枚举、结构体使用时注意加mutating关键字 init: 123456789101112131415161718192021222324// 协议中还可以定义初始化器init // 非final类实现时必须加上requiredprotocol Drawable &#123; init(x: Int, y: Int)&#125;class Point : Drawable &#123; required init(x: Int, y: Int) &#123;&#125;&#125;final class Size : Drawable &#123; init(x: Int, y: Int) &#123;&#125;&#125;// 如果从协议实现的初始化器，刚好是重写了父类的指定初始化器 // 那么这个初始化必须同时加required、overrideprotocol Livable &#123; init(age: Int)&#125;class Person &#123; init(age: Int) &#123;&#125;&#125;class Student : Person, Livable &#123; required override init(age: Int) &#123; super.init(age: age) &#125;&#125; init、init?、init!: 协议中定义的init?、init!，可以用init、init?、init!去实现 协议中定义的init，可以用init、init!去实现 #####27. CaseIterable 协议 12345678// 让枚举遵守CaseIterable协议，可以实现遍历枚举值enum Season : CaseIterable &#123; case spring, summer, autumn, winter&#125;let seasons = Season.allCases print(seasons.count) // 4 for season in seasons &#123; print(season)&#125; // spring summer autumn winter #####28. CustomStringConvertible 遵守CustomStringConvertible、 CustomDebugStringConvertible协议，都可以自定义实例的打印字符串12345678class Person : CustomStringConvertible, CustomDebugStringConvertible &#123; var age = 0 var description: String &#123; &quot;person_\\(age)&quot; &#125; var debugDescription: String &#123; &quot;debug_person_\\(age)&quot; &#125; &#125;var person = Person()print(person) // person_0 debugPrint(person) // debug_person_0 print调用的是CustomStringConvertible协议的descriptiondebugPrint、po调用的是CustomDebugStringConvertible协议的debugDescription #####29. Any、AnyObject Any:可以代表任意类型(枚举、结构体、类，也包括函数类型) AnyObject:可以代表任意类类型(在协议后面写上: AnyObject代表只有类能遵守这个协议)在协议后面写上: class也代表只有类能遵守这个协议 30. is、as?、as!、as is用来判断是否为某种类型，as用来做强制类型转换 #####31. X.self、X.Type、AnyClass X.self(对应OC中的类对象)是一个元类型(metadata)的指针，metadata存放着类型相关信息 X.self属于X.Type类型(对应OC中的元类对象) 12345678910111213141516171819202122232425262728293031class Person &#123;&#125;class Student : Person &#123;&#125;var perType: Person.Type = Person.self var stuType: Student.Type = Student.self perType = Student.selfvar anyType: AnyObject.Type = Person.self anyType = Student.selfpublic typealias AnyClass = AnyObject.Type var anyType2: AnyClass = Person.self anyType2 = Student.selfvar per = Person()var perType = type(of: per) // Person.self print(Person.self == type(of: per)) // true //元类型的应用class Animal &#123; required init() &#123;&#125; &#125; class Cat : Animal &#123;&#125;class Dog : Animal &#123;&#125;class Pig : Animal &#123;&#125;func create(_ clses: [Animal.Type]) -&gt; [Animal] &#123; var arr = [Animal]() for cls in clses &#123; arr.append(cls.init()) &#125; return arr &#125;print(create([Cat.self, Dog.self, Pig.self])) Swift还有个隐藏的基类:Swift._SwiftObject 源码连接 #####32.大写Self1234567891011121314151617181920212223242526272829Self// Self代表当前类型class Person &#123; var age = 1 static var count = 2 func run() &#123; print(self.age) // 1 print(Self.count) // 2 等价于Person.count &#125;&#125;// Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型(也可以作为参数类型)protocol Runnable &#123; func test() -&gt; Self&#125;class Person : Runnable &#123; required init() &#123;&#125; func test() -&gt; Self &#123; type(of: self).init() &#125; &#125;class Student : Person &#123;&#125;var p = Person() // Person print(p.test())var stu = Student() // Student print(stu.test()) #####33.错误处理 自定义错误:123456789101112131415// Swift中可以通过Error协议自定义运行时的错误信息enum SomeError : Error &#123; case illegalArg(String) case outOfBounds(Int, Int) case outOfMemory&#125;// 函数内部通过throw抛出自定义Error，可能会抛出Error的函数必须加上throws声明 func divide(_ num1: Int, _ num2: Int) throws -&gt; Int &#123; if num2 == 0 &#123; throw SomeError.illegalArg(&quot;0不能作为除数&quot;) &#125; return num1 / num2&#125;// 需要使用try调用可能会抛出Error的函数var result = try divide(20, 10) 处理Error的3种方式： 1 通过do-catch捕捉Error2 不捕捉Error，在当前函数增加throws声明，Error将自动抛给上层函数， 如果最顶层函数(main函数)依然没有捕捉Error，那么程序将终止3 可以使用try?、try!调用可能会抛出Error的函数，这样就不用去处理Error 抛出Error后，try下一句直到作用域结束的代码都将停止运行 rethrowsrethrows表明:函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛 12345func exec(_ fn: (Int, Int) throws -&gt; Int, _ num1: Int, _ num2: Int) rethrows &#123; print(try fn(num1, num2))&#125;// Fatal error: Error raised at top leveltry exec(divide, 20, 0) defer defer语句:用来定义以任何方式(抛错误、return等)离开代码块前必须要执行的代码 defer语句将延迟至当前作用域结束之前执行12345678// defer语句的执行顺序与定义顺序相反func test() &#123; defer &#123; fn1() &#125; defer &#123; fn2() &#125;&#125;test()// fn2// fn1 assert(断言) 很多编程语言都有断言机制:不符合指定条件就抛出运行时错误，常用于调试(Debug)阶段的条件判断 默认情况下，Swift的断言只会在Debug模式下生效，Release模式下会忽略 增加Swift Flags修改断言的默认行为p-assert-config Release:强制关闭断言p-assert-config Debug:强制开启断言 fatalError 如果遇到严重问题，希望结束程序运行时，可以直接使用fatalError函数抛出错误(这是无法通过do-catch捕捉的错误) 使用了fatalError函数，就不需要再写return 在某些不得不实现、但不希望别人调用的方法，可以考虑内部使用fatalError函数 #####34.泛型 泛型可以将类型参数化，提高代码复用率，减少代码量 12// 泛型函数赋值给变量func swapValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; (a, b) = (b, a) &#125; 关联类型(Associated Type)关联类型的作用:给协议中用到的类型定义一个占位名称。就是协议中泛型的实现协议中可以拥有多个关联类型 12345678910111213141516171819 protocol Stackable &#123; associatedtype Element // 关联类型 mutating func push(_ element: Element) mutating func pop() -&gt; Element func top() -&gt; Element func size() -&gt; Int&#125;class StringStack : Stackable &#123; // 给关联类型设定真实类型 // typealias Element = String var elements = [String]() func push(_ element: String) &#123; elements.append(element) &#125; func pop() -&gt; String &#123; elements.removeLast() &#125; func top() -&gt; String &#123; elements.last! &#125; func size() -&gt; Int &#123; elements.count &#125; &#125;var ss = StringStack() ss.push(&quot;Jack&quot;) ss.push(&quot;Rose&quot;) where类型约束 123456789 protocol Stackable &#123;associatedtype Element: Equatable &#125; class Stack&lt;E : Equatable&gt; : Stackable &#123; typealias Element = E &#125; func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool where S1.Element == S2.Element, S1.Element : Hashable &#123;return false &#125; 协议类型的注意点 some 不透明类型应用 1234567891011121314151617181920212223242526272829 泛型解决 // 解决方案1:使用泛型func get&lt;T : Runnable&gt;(_ type: Int) -&gt; T &#123; if type == 0 &#123; return Person() as! T &#125; return Car() as! T&#125;var r1: Person = get(0)var r2: Car = get(1)不透明类型(Opaque Type): 屏蔽内部实现细节// 解决方案2:使用some关键字声明一个不透明类型 // some限制只能返回一种类型 func get(_ type: Int) -&gt; some Runnable &#123; Car() &#125; var r1 = get(0)var r2 = get(1) // some// some除了用在返回值类型上，一般还可以用在属性类型上protocol Runnable &#123; associatedtype Speed &#125;class Dog : Runnable &#123; typealias Speed = Double &#125;class Person &#123; var pet: some Runnable &#123; return Dog() &#125; &#125; 可选项的本质是enum类型 12345678910111213141516171819202122232425262728293031323334353637public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123; case none // nil case some(Wrapped) // 关联值 public init(_ some: Wrapped) &#125;var age: Int? = .none age = 10age = .some(20)age = nilvar age: Int? = 10var age0: Optional&lt;Int&gt; = Optional&lt;Int&gt;.some(10)var age1: Optional = .some(10)var age2 = Optional.some(10)var age3 = Optional(10)age = nilage3 = .none// 两种判断nil的写法switch age &#123; // 默认会解包 case let v?: print(&quot;some&quot;, v) case nil: print(&quot;none&quot;)&#125;switch age &#123; case let .some(v): print(&quot;some&quot;, v) case .none: print(&quot;none&quot;)&#125; #####35. 关于String的本质探索 1234567891011121314 // 字符串长度 &lt;= 0xF(15)，字符串内容直接存放在str1变量的内存中。（类似OC中的tagger pointer 技术）var str1 = &quot;0123456789&quot;// 字符串长度 &gt; 0xF，字符串内容存放在__TEXT.cstring中（常量区）// 字符串的地址值信息存放在str2变量的后8个字节中var str2 = &quot;0123456789ABCDEF&quot;// 由于字符串长度 &lt;= 0xF，所以字符串内容依然存放在str1变量的内存中str1.append(&quot;ABCDE&quot;)// 开辟堆空间str1.append(&quot;F&quot;)// 开辟堆空间str2.append(&quot;G&quot;) #####36.call，jmp指令区别 call会把他的下一条指令的地址压入堆栈，然后跳转到他调用的开始处，同时ret会自动弹出返回地址。 JMP只是简单的跳转call的本质相当于push+jmp ret的本质相当于pop+jmp #####37.高级运算符 溢出运算符(Overflow Operator)： Swift的算数运算符出现溢出时会抛出运行时错误 Swift有溢出运算符(&amp;+、&amp;-、&amp;*)，用来支持溢出运算 12345678var min = UInt8.minprint(min &amp;- 1) // 255, Int8.maxvar max = UInt8.maxprint(max &amp;+ 1) // 0, Int8.min print(max &amp;* 2) // 254, 等价于 max &amp;+ max// 逐渐递增UInt8.min 0UInt8.max 255 运算符重载(Operator Overload): 类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做:运算符重载123456789101112131415161718192021222324 struct Point : Equatable &#123; var x = 0, y = 0 static func + (p1: Point, p2: Point) -&gt; Point &#123; Point(x: p1.x + p2.x, y: p1.y + p2.y) &#125; static func - (p1: Point, p2: Point) -&gt; Point &#123; Point(x: p1.x - p2.x, y: p1.y - p2.y) &#125; static prefix func - (p: Point) -&gt; Point &#123; Point(x: -p.x, y: -p.y) &#125; static func += (p1: inout Point, p2: Point) &#123; p1 = p1 + p2 &#125; static prefix func ++ (p: inout Point) -&gt; Point &#123; p += Point(x: 1, y: 1) return p &#125; static postfix func ++ (p: inout Point) -&gt; Point &#123; let tmp = p p += Point(x: 1, y: 1) return tmp &#125;&#125; Equatable: 要想得知2个实例是否等价，一般做法是遵守Equatable 协议，重载== 运算符 与此同时，等价于重载了 != 运算符 Swift为以下类型提供默认的Equatable 实现 没有关联类型的枚举 只拥有遵守 Equatable 协议关联类型的枚举 只拥有遵守 Equatable 协议存储属性的结构体 引用类型比较存储的地址值是否相等(是否引用着同一个对象)，使用恒等运算符=== 、!== Comparable 要想比较2个实例的大小，一般做法是: 1.遵守 Comparable 协议 2.重载相应的运算符123456789101112131415161718192021222324252627282930313233 // score大的比较大，若score相等，age小的比较大 struct Student : Comparable &#123; var age: Int var score: Int init(score: Int, age: Int) &#123; self.score = score self.age = age &#125; static func &lt; (lhs: Student, rhs: Student) -&gt; Bool &#123; (lhs.score &lt; rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age &gt; rhs.age) &#125; static func &gt; (lhs: Student, rhs: Student) -&gt; Bool &#123; (lhs.score &gt; rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age &lt; rhs.age) &#125; static func &lt;= (lhs: Student, rhs: Student) -&gt; Bool &#123; !(lhs &gt; rhs) &#125; static func &gt;= (lhs: Student, rhs: Student) -&gt; Bool &#123; !(lhs &lt; rhs) &#125; &#125;var stu1 = Student(score: 100, age: 20) var stu2 = Student(score: 98, age: 18) var stu3 = Student(score: 100, age: 20) print(stu1 &gt; stu2) // trueprint(stu1 &gt;= stu2) // trueprint(stu1 &gt;= stu3) // trueprint(stu1 &lt;= stu3) // trueprint(stu2 &lt; stu1) // trueprint(stu2 &lt;= stu1) // true 自定义运算符(Custom Operator) 可以自定义新的运算符:在全局作用域使用operator进行声明123456789101112131415161718 prefix operator 前缀运算符postfix operator 后缀运算符infix operator 中缀运算符 : 优先级组precedencegroup 优先级组 &#123; associativity: 结合性(left\\right\\none) higherThan: 比谁的优先级高 lowerThan: 比谁的优先级低 assignment: true代表在可选链操作中拥有跟赋值运算符一样的优先级&#125;prefix operator +++infix operator +- : PlusMinusPrecedence precedencegroup PlusMinusPrecedence &#123; associativity: none higherThan: AdditionPrecedence lowerThan: MultiplicationPrecedence assignment: true&#125; Apple文档参考1Apple文档参考2 示例：12345678910111213141516171819 struct Point &#123; var x: Int, y: Int static prefix func +++ (point: inout Point) -&gt; Point &#123; point = Point(x: point.x + point.x, y: point.y + point.y) return point &#125; static func +- (left: Point, right: Point) -&gt; Point &#123; return Point(x: left.x + right.x, y: left.y - right.y) &#125; static func +- (left: Point?, right: Point) -&gt; Point &#123; print(&quot;+-&quot;) return Point(x: left?.x ?? 0 + right.x, y: left?.y ?? 0 - right.y) &#125;&#125;struct Person &#123; var point: Point&#125;var person: Person? = nil person?.point +- Point(x: 10, y: 20) #####38. 扩展(Extension) Swift中的扩展，有点类似于OC中的分类(Category) 扩展可以为枚举、结构体、类、协议添加新功能 可以添加方法、计算属性、下标、(便捷)初始化器、嵌套类型、协议等等 扩展不能办到的事情: 不能覆盖原有的功能不能添加存储属性，不能向已有的属性添加属性观察器不能添加父类不能添加指定初始化器，不能添加反初始化器… 协议拓展扩展可以给协议提供默认实现，也间接实现『可选协议』的效果扩展可以给协议扩充『协议中从未声明过的方法』 注意下面代码的打印信息： 12345678910111213141516171819202122232425262728 protocol TestProtocol &#123; func test1() &#125; extension TestProtocol &#123; func test1() &#123; print(&quot;TestProtocol test1&quot;) &#125; func test2() &#123; print(&quot;TestProtocol test2&quot;) &#125; &#125;class TestClass : TestProtocol &#123; func test1() &#123; print(&quot;TestClass test1&quot;) &#125; func test2() &#123; print(&quot;TestClass test2&quot;) &#125;&#125;var cls = TestClass()cls.test1() // TestClass test1 cls.test2() // TestClass test2var cls2: TestProtocol = TestClass() cls2.test1() // TestClass test1 cls2.test2() // TestProtocol test2 ``` - 泛型拓展： // 符合条件才扩展(只有Stack中的元素遵守Equatable协议，拓展才有效)extension Stack : Equatable where E : Equatable { static func == (left: Stack, right: Stack) -&gt; Bool { left.elements == right.elements }} 12345678910111213141516171819202122232425262728293031323334- #####39.访问控制(Access Control) - 在访问权限控制这块，Swift提供了5个不同的访问级别(以下是从高到低排列， 实体指***被访问级别修饰的内容***) &gt; open:允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写(open只能用在类、类成员上) &gt; public:允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写 &gt; internal:只允许在定义实体的模块中访问，不允许在其他模块中访问 &gt; fileprivate:只允许在定义实体的源文件中访问&gt; private:只允许在定义实体的封闭声明中访问 `绝大部分实体默认都是internal 级别` - 访问级别的使用准则:`一个实体不可以被更低访问级别的实体定义`&gt;1.元祖，泛型都以最低那个为准&gt;2.协议实现不得小于协议和类中的较小的那个&gt;3.枚举不能每项单独定义&gt;4.public 限定作用域内部默认是internal&gt;5.required初始化器 ≥ 它的默认访问级别- `直接在全局作用域下定义的private等价于fileprivate`- #####40.内存管理- 跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案(针对堆空间) - Swift的ARC中有3种引用: - 1.强引用(`strong reference`):默认情况下，引用都是强引用 - 2.弱引用(`weak reference`):通过weak定义弱引用 - 必须是可选类型的var，因为实例销毁后，***ARC会自动将弱引用设置为nil*** - ARC自动给弱引用设置nil时，不会触发属性观察器 - 3.无主引用(`unowned reference`):通过unowned定义无主引用 - ***不会产生强引用，实例销毁后仍然存储着实例的内存地址***(类似于OC中的unsafe_unretained) - 试图在实例销毁后访问无主引用，会产生运行时错误(野指针)• Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated - 用`inout`输入输出参数时，注意内存访问冲突问题 - 内存访问冲突(Conflicting Access to Memory) &gt;内存访问冲突会在两个访问满足下列条件时发生: 至少一个是写入操作 它们访问的是同一块内存 它们的访问时间重叠(比如在同一个函数内) // 不存在内存访问冲突func plus(_ num: inout Int) -&gt; Int { num + 1 } var number = 1number = plus(&amp;number) // 存在内存访问冲突// Simultaneous accesses to 0x0, but modification requires exclusive access var step = 1func increment(_ num: inout Int) { num += step }increment(&amp;step) // 解决内存访问冲突var copyOfStep = stepincrement(&amp;copyOfStep)step = copyOfStep` 以上均根据CoderMJLee老师的视频及资料整理，祝小码哥教育越来越好，特此感谢！！！ 如有侵权，请联系删除：fm939071955@163.com","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://blogzhou.top/tags/Swift/"}]},{"title":"OC/Swift混编的一些小知识","slug":"s10-OC-Swift混编的一些小知识","date":"2019-04-15T12:31:57.000Z","updated":"2020-12-16T06:20:33.058Z","comments":true,"path":"2019/04/15/s10-OC-Swift混编的一些小知识/","link":"","permalink":"http://blogzhou.top/2019/04/15/s10-OC-Swift混编的一些小知识/","excerpt":"Swift调用OC桥接头文件: 1.新建1个桥接头文件，文件名格式默认为:{targetName}-Bridging-Header.h2.在{targetName}-Bridging-Header.h 文件中#import OC需要暴露给Swift的内容(可通过编译器自动生成) @_silgen_name关键字： 1.如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了2.可以在Swift中使用 @_silgen_name 修改C函数名（可以用此方法调用系统底层函数）12345678910// C语言int sum(int a, int b) &#123;return a + b; &#125;// Swift@_silgen_name(&quot;sum&quot;) func swift_sum(_ v1: Int32, _ v2: Int32) -&gt; Int32print(swift_sum(10, 20)) // 30print(sum(10, 20)) // 30","text":"Swift调用OC桥接头文件: 1.新建1个桥接头文件，文件名格式默认为:{targetName}-Bridging-Header.h2.在{targetName}-Bridging-Header.h 文件中#import OC需要暴露给Swift的内容(可通过编译器自动生成) @_silgen_name关键字： 1.如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了2.可以在Swift中使用 @_silgen_name 修改C函数名（可以用此方法调用系统底层函数）12345678910// C语言int sum(int a, int b) &#123;return a + b; &#125;// Swift@_silgen_name(&quot;sum&quot;) func swift_sum(_ v1: Int32, _ v2: Int32) -&gt; Int32print(swift_sum(10, 20)) // 30print(sum(10, 20)) // 30 OC调用Swift Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是: {targetName}-Swift.h Swift暴露给OC的类最终继承自NSObject 使用@objc修饰需要暴露给OC的成员 使用@objcMembers修饰类 代表默认所有成员都会暴露给OC(包括扩展中定义的成员) 最终是否成功暴露，还需要考虑成员自身的访问级别 @objc:123456789101112131415161718// 可以通过@objc 重命名Swift暴露给OC的符号名(类名、属性名、函数名等)@objc(MJCar)@objcMembers class Car: NSObject &#123; var price: Double @objc(name) var band: String init(price: Double, band: String) &#123; self.price = price self.band = band &#125; @objc(drive) func run() &#123; print(price, band, &quot;run&quot;) &#125; static func run() &#123; print(&quot;Car run&quot;) &#125;&#125;extension Car &#123; @objc(exec:v2:) func test() &#123; print(price, band, &quot;test&quot;) &#125; &#125; 选择器(Selector):1234567891011121314// Swift中依然可以使用选择器，使用#selector(name)定义一个选择器 // 必须是被@objcMembers或@objc修饰的方法才可以定义选择器@objcMembers class Person: NSObject &#123; func test1(v1: Int) &#123; print(&quot;test1&quot;) &#125; func test2(v1: Int, v2: Int) &#123; print(&quot;test2(v1:v2:)&quot;) &#125; func test2(_ v1: Double, _ v2: Double) &#123; print(&quot;test2(_:_:)&quot;) &#125; func run() &#123; perform(#selector(test1)) perform(#selector(test1(v1:))) perform(#selector(test2(v1:v2:))) perform(#selector(test2(_:_:))) perform(#selector(test2 as (Double, Double) -&gt; Void)) &#125; &#125; dynamic 被 @objc dynamic 修饰的内容会具有动态性，比如调用方法会走runtime那一套流程1234567class Dog: NSObject &#123; @objc dynamic func test1() &#123;&#125; func test2() &#123;&#125;&#125;var d = Dog() d.test1()d.test2() Swift语言中的一些编译器特性：代码注释相关： // MARK: 类似于OC中的 #pragma mark// MARK: - 类似于OC中的 #pragma mark -// TODO: 用于标记未完成的任务// FIXME: 用于标记待修复的问题#warning(&quot;undo&quot;) 条件编译：1234567891011// 操作系统:macOS\\iOS\\tvOS\\watchOS\\Linux\\Android\\Windows\\FreeBSD #if os(macOS) || os(iOS)// CPU架构:i386\\x86_64\\arm\\arm64#elseif arch(x86_64) || arch(arm64)// swift版本#elseif swift(&lt;5) &amp;&amp; swift(&gt;=3)// 模拟器#elseif targetEnvironment(simulator) // 可以导入某模块#elseif canImport(Foundation)#else#endif 系统版本检测:1234if #available(iOS 10, macOS 10.12, *) &#123; // 对于iOS平台，只在iOS10及以上版本执行 // 对于macOS平台，只在macOS 10.12及以上版本执行 // 最后的*表示在其他所有平台都执行&#125; API可用性说明:12345678910@available(iOS 10, macOS 10.15, *) class Person &#123;&#125;struct Student &#123; @available(*, unavailable, renamed: &quot;study&quot;) func study_() &#123;&#125; func study() &#123;&#125; @available(iOS, deprecated: 11) @available(macOS, deprecated: 10.12) func run() &#123;&#125;&#125; 更多用法参考自定义打印:123456789func logger&lt;T&gt;(_ msg: T, file: NSString = #file, line: Int = #line, fn: String = #function) &#123; #if DEBUG let prefix = &quot;\\(file.lastPathComponent)_\\(line)_\\(fn):&quot; print(prefix, msg) #endif&#125;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://blogzhou.top/tags/Swift/"}]},{"title":"几种常见的排序","slug":"t08.几种常见的排序","date":"2018-05-03T06:42:15.000Z","updated":"2020-12-15T04:48:38.581Z","comments":true,"path":"2018/05/03/t08.几种常见的排序/","link":"","permalink":"http://blogzhou.top/2018/05/03/t08.几种常见的排序/","excerpt":"1.冒泡排序1234567891011121314/* 冒泡排序 */ for (int end = cnt - 1; end &gt; 0 ; end --) &#123; for (int begin = 1; begin &lt;= end; begin ++) &#123; // 优化-减少已排序部分的比较 int startIndex = 1; if (array[begin - 1] &lt; array[begin]) &#123; int tmp = array[begin - 1]; array[begin - 1] = array[begin]; array[begin] = tmp; startIndex = begin; &#125; end = startIndex; &#125; &#125;","text":"1.冒泡排序1234567891011121314/* 冒泡排序 */ for (int end = cnt - 1; end &gt; 0 ; end --) &#123; for (int begin = 1; begin &lt;= end; begin ++) &#123; // 优化-减少已排序部分的比较 int startIndex = 1; if (array[begin - 1] &lt; array[begin]) &#123; int tmp = array[begin - 1]; array[begin - 1] = array[begin]; array[begin] = tmp; startIndex = begin; &#125; end = startIndex; &#125; &#125; 2.选择排序123456789101112// - 比较后，记录最大索引，最后进行交换。for (int end= cnt - 1; end &gt; 0; end--) &#123; int maxIndex = 0; for (int begin = 1; begin &lt;= end; begin++) &#123; if(array[maxIndex] &lt;= array[begin]) &#123; maxIndex = begin; &#125; &#125; int tmp = array[end]; array[end] = array[maxIndex]; array[maxIndex] = tmp; &#125; 3.堆排序12345678910111213141516171819202122232425262728293031323334353637int array[] = &#123;9, 5, 2, 7&#125;;int heapSize = array.length;void sort() &#123; heapify(); while (heapSize &gt; 1) &#123; int tmp = array[heapSize - 1]; array[heapSize - 1] = array[0]; array[0] = temp; heapSize--; siftDown(0); &#125;&#125;// 建堆void heapify() &#123; for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i --) &#123; siftDown(i); &#125;&#125;// 自下而上的下滤void siftDown(int index) &#123; int current = array[index]; int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; int childIndex = (index &lt;&lt; 1) + 1; int child = array[childIndex]; int rightIndex = childIndex + 1; if (rightIndex &lt; heapSize &amp;&amp; array[rightIndex] &gt; child) &#123; child = array[childeIndex = rightIndex]; &#125; if (current &gt;= child) break; array[index] = child; index = childIndex; &#125; array[index] = current;&#125; 4.插空排序 代码解析见注释。 1234567891011121314151617181920212223242526272829int a[5]=&#123;9, 8, 10, 2, 20&#125;;// key为每次被拿出的值（也就是初始提供“空”的值），j为要比较到的最大索引int key,j;// 直接插入排序for (int i=1; i&lt;5; i++) &#123; // 取出当前要比较项 key=a[i]; // 和直到索引j位置的元素逐一比较 for (j=i-1; j&gt;=0&amp;&amp;a[j]&gt;key; j--) &#123; // j为更新出来的新空 a[j+1]=a[j]; &#125; // 因为循环结束时进行一次j--操作，所以下面要+1 // j+1为最后留给key的空 a[j+1]=key;&#125;// 另一种写法for (int begin=1; begin &lt; 5; begin++) &#123; // 记录当前索引（当前空位） int cur = begin; int val = a[cur]; // 和直到索引j位置的元素逐一比较 while (cur &gt; 0 &amp;&amp; val &gt; a[cur - 1]) &#123; // j为更新出来的新空 a[cur] = a[cur - 1]; cur --; &#125; a[cur] = val;&#125; 二分查找 12345678910111213141516171819// 返回找到的元素对应的索引，没找到返回-1int binarySearch(int array[], int v) &#123; if (array == null || array.length == 0) &#123; retrun -1; &#125; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &gt; array[mid]) &#123; begin = mid + 1; &#125; else if (v &lt; array[mid]) &#123; end = mid; &#125; else &#123; return mid; &#125; &#125; return -1;&#125; 结合二分查找优化插空排序 12345678910111213141516171819202122232425262728void insertSort(int [] array) &#123; for (int begin = 1; begin &lt; array.length; begin++) &#123; insert(begin, search(begin)); &#125;&#125;// 执行插入的元素位移操作void insert(int source, int target) &#123; int v = array[source]; for (int i = source; i &gt; target; i --) &#123; array[source] = array[source - 1]; &#125; array[target] = v;&#125;// 用二分法查找当前取出的元素在已排好序部分对应的插入位置int search(int index) &#123; int v = array[index]; int begin = 0; int end = index; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &gt;= array[mid]) &#123; begin = mid + 1; &#125; else &#123; end = mid; &#125; &#125; return begin;&#125; 5.归并排序123456789101112131415161718192021222324252627282930313233int[] array = &#123;9, 5, 2, 7&#125;;void mergeSort() &#123; sortRecursive(0, array.length);&#125;void sortRecursive(int begin, int end) &#123; // 数组只剩一个元素，不能再分了 if (end - begin &lt; 2) return; int mid = (begin + end) &gt;&gt; 1; sortRecursive(begin, mid); sortRecursive(mid, end); merge(begin, mid, end);&#125;// 用来存放左边排好序部分的备用数组int leftArray[] = new int[array.length &gt;&gt; 1];void merge(int begin, int mid, int end) &#123; int lp = 0, le = mid - begin; int rp = mid, re = end; int ap = begin; for (int i = 0; i &lt; le; i ++) &#123; leftArray[i] = array[begin + i]; &#125; // 只要左边结束了，整个排序就结束了 while (lp &lt; le) &#123; if (rp &lt; re &amp;&amp; array[rp] &lt; leftArray[lp]) &#123; array[ap++] = array[rp++]; &#125; else &#123; array[ap] = leftArray[lp]; ap ++; lp ++; &#125; &#125;&#125; 6.快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int[] array = &#123;9, 5, 2, 7&#125;;void pivotSort() &#123; pivotRecursive(0, array.length);&#125;void pivotRecursive(int begin, int end) &#123; if (end - begin &lt; 2) return; // 找到轴点的位置 int pivot = pivotIndex(begin, end); // 递归轴点左 pivotRecursive(begin, pivot); // 递归轴点右 pivotRecursive(pivot + 1, end);&#125;int pivotIndex(int begin, int end) &#123; // 优化：为了轴点左右数据更加均衡，随机选择轴点 int random = random(end - begin); int tmp = array[begin]; array[begin] = array[random]; array[random] = tmp; int v = array[begin]; // 因为end是从array.length开始的，所以要-- end--; // 嵌套while循环实现左右交替执行 while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (array[end] &gt; v) &#123; end--; &#125; else &#123; array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (array[begin] &lt; v) &#123; begin++; &#125; else &#123; array[end--] = array[begin]; break; &#125; &#125; &#125; array[begin] = v; return begin&#125; 7.希尔排序 可看作是对插空排序的优化1234567891011121314151617181920212223242526int[] array = &#123;9, 5, 2, 7&#125;;void shellSort() &#123; int[] steps = step(array.length); for (int i = 0; i &lt; steps.length; i ++) &#123; int step = steps[i]; for (int col = 0; col &lt; step; col ++) &#123; for (int begin = col + step; begin &lt; array.length; begin += step) &#123; int cur = begin; int v = array[cur]; while (cur &gt; col &amp;&amp; v &gt; array[cur - step]) &#123; array[cur] = array[cur - step]; cur -=step; &#125; arrau[cur] = v; &#125; &#125; &#125;&#125;// 创建步长数组int[] step(int step) &#123; int[] steps = new int[]; while ((step &gt;&gt;= 1) &gt; 0) &#123; steps.add(step) &#125; return step;&#125; 8.计数排序 中心思想：用空间换时间 只适用于一定范围内的整数排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int[] array = &#123;9, 5, 2, 7&#125;;// 仅支持正整数版本// 找出最大值int max = array[0];for (int i = 1; i &lt; array.length; i ++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125;&#125;// 创建计数数组int[] counts = new int[max + 1];for (int i = 0; i &lt; array.length; i ++) &#123; conuts[array[i]] += 1;&#125;// 输出排好序的数组int index = 0;for (int i = 0; i &lt; counts.length; i ++) &#123; while ((counts[i]--) &gt; 0) &#123; array[index++] = i; &#125;&#125;// 优化版本，支持负整数(包含整数属性排序的自定义对象也可以)// 找出最大值，最小值int max = array[0];int min = array[0];for (int i = 1; i &lt; array.length; i ++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125;&#125;// 计数数组int[] counts = new int[max - min + 1];for (int i = 0; i &lt; array.length; i ++) &#123; conuts[array[i] - min] += 1;&#125;// 累加次数for （int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1];&#125;// 从后往前遍历元素，将它放到有序数组中的合适位置int newArray = new int[array.length];for (int i = array.length - 1; i &gt;=0; i --) &#123; newArray[--counts[array[i] - min]] = array[i];&#125;// 将有序数组赋值到arrayfor (int i = 0; i &lt; array.length; i ++) &#123; array[i] = newArray[i];&#125; 9.基数排序 数据从低位到高位按位排序 排序用计数排序1234567891011121314151617181920212223242526272829303132333435int[] array = &#123;9, 5, 2, 7&#125;;// 仅支持正整数版本// 找出最大值int max = array[0];for (int i = 1; i &lt; array.length; i ++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125;&#125;// 创建计数数组int[] counts = new int[max + 1];for (int devider = 1; devider &lt; max; devider * 10) &#123; countingSort(devider);&#125;void countingSort(int devide) &#123; // 计数数组 int[] counts = new int[10]; for (int i = 0; i &lt; array.length; i ++) &#123; conuts[array[i] / devide % 10] += 1; &#125; // 累加次数 for （int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中的合适位置 int newArray = new int[array.length]; for (int i = array.length - 1; i &gt;=0; i --) &#123; newArray[--counts[array[i] / devide % 10]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; array.length; i ++) &#123; array[i] = newArray[i]; &#125;&#125; 10.桶排序 自定义规则 按规则尽量均匀分布数据到每个桶 对桶内数据排序 将桶内数据串起来 以上均为伪代码，仅提供思路 整体测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#import &lt;Foundation/Foundation.h&gt;void initArray(int array[],int cnt);void selectSortForArray(int array[],int cnt);void showArray(int array[],int cnt);void initArray(int array[],int cnt)&#123; for(int i= 0;i&lt;cnt;i++) array[i] = arc4random() % 100;&#125;void selectSortForArray(int array[],int cnt)&#123; /*for (int i = 0; i&lt;cnt-1; i++)&#123; for (int j = i+1; j&lt;cnt; j++) &#123;if (array[i] &lt; array[j]) &#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125;&#125;&#125;*/ //****************这样每次比较后都交换元素位置********** for (int i= 0;i&lt;cnt-1;i++)&#123; for (int j=i + 1;j&lt;cnt;j++)&#123; if(array[i]&lt;array[j])&#123; int tmp=array[i]; array[i]=array[j]; array[j]=tmp; &#125; &#125;// &#125;//*****************这样每次比较只记住索引，内循环遍历一次完成后再交换（减少交换次数），********* for (int i = 0; i &lt; cnt - 1; i++) &#123; int tmp = 0; for (int j = i + 1; j &lt; cnt; j++) &#123; if (array[i] &lt; array[j]) &#123; tmp = j; &#125; int c = array[i]; array[i] = array[tmp]; array[tmp] = c; &#125; &#125; /* 冒泡排序 */ for (int i = 0; i &lt; cnt - 1; i ++) &#123; for (int j = 0; j &lt; cnt - i - 1; j ++) &#123; if (array[j] &lt; array[j + 1]) &#123; int tmp = array[j]; array[j] = array[j + 1]; array[j + 1] = tmp; &#125; &#125; &#125;&#125;void showArray(int array[],int cnt)&#123; for (int i = 0; i&lt;cnt; i++) &#123; printf(&quot;%d &quot;,array[i]); &#125; printf(&quot;\\n&quot;);&#125;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // insert code here...// NSLog(@&quot;Hello, World!&quot;);// int array[10] = &#123;0&#125;; initArray(array, 10); showArray(array,10); selectSortForArray(array, 10); showArray(array,10); // C-实现 插空排序 int a[5]=&#123;9,8,10,2,20&#125;; int key,j;// key为每次被拿出的值（也就是初始提供“空”的值），j为要比较到的最大索引 for (int i=1; i&lt;5; i++) &#123;// 直接插入排序 key=a[i];// 取出当前要比较项 for (j=i-1; j&gt;=0&amp;&amp;a[j]&gt;key; j--) &#123;// 和直到索引j位置的元素逐一比较 a[j+1]=a[j];// j为更新出来的新空（但是只要进了循环，此次循环结束就会进行一次j--操作，所以下面要+1） &#125; a[j+1]=key;// j+1为最后留给key的空 &#125; for (int i=0; i&lt;5; i++) &#123;// NSLog(@&quot;%i&quot;,a[i]); &#125; // OC实现// NSMutableArray *array=[NSMutableArray arrayWithObjects:@9,@8,@10,@2,@20, nil];// id key;// NSInteger j;// for (NSInteger i=1; i&lt;array.count; i++) &#123;// key=[array objectAtIndex:i];//取到每一个待插入的数据,从a[1]开始查找// for (j=i-1; j&gt;=0&amp;&amp;array[j]&gt;key; j--) &#123;// // 如果之前的数比key大,就将这个数向后移动一个位置,留出空来让key插入就像整牌一样//// [array exchangeObjectAtIndex:j+1 withObjectAtIndex:j];//交换// &#125;// [array replaceObjectAtIndex:j+1 withObject:key];// &#125;// for (key in array) &#123;// NSLog(@&quot;%@&quot;,key);// &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"code","slug":"code","permalink":"http://blogzhou.top/tags/code/"}]},{"title":"Node环境配置","slug":"t05.Node环境配置","date":"2018-03-12T01:43:45.000Z","updated":"2020-07-18T03:20:22.694Z","comments":true,"path":"2018/03/12/t05.Node环境配置/","link":"","permalink":"http://blogzhou.top/2018/03/12/t05.Node环境配置/","excerpt":"方式一：安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本）","text":"方式一：安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） 方式二：NVM工具的使用 Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 安装操作步骤一 、Mac OS： 比较简单，自行参考这个链接地址 https://github.com/creationix/nvm二、Windows： 下载：nvm-windows 解压到一个全英文路径 编辑解压目录下的settings.txt文件（不存在则新建）文件内容如图： root 配置为当前 nvm.exe 所在目录 path 配置为 node 快捷方式所在的目录 arch 配置为当前操作系统的位数（32/64） proxy 不用配置 配置环境变量 可以通过 window+r : sysdm.cpl TMP下新建 NVM_HOME = 当前 nvm.exe 所在目录 NVM_SYMLINK = node 快捷方式所在的目录 PATH += %NVM_HOME%;%NVM_SYMLINK%; 打开CMD通过set [name]命令查看环境变量是否配置成功 PowerShell中是通过dir env:[name]命令 NVM使用说明： https://github.com/coreybutler/nvm-windows/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://blogzhou.top/tags/tool/"}]},{"title":"Favorite Words","slug":"p04.Favorite Words","date":"2018-03-08T03:25:54.000Z","updated":"2020-07-18T03:20:22.696Z","comments":true,"path":"2018/03/08/p04.Favorite Words/","link":"","permalink":"http://blogzhou.top/2018/03/08/p04.Favorite Words/","excerpt":"那些动听的想法如果不能趁年轻易感的时候去实现，消逝的速度比云还快。 即使有人告诉我，山的那边还是山，我依然想一路小跑翻山越岭，亲自感慨：“我靠！他说的是真的诶！” 与天地等量齐观的眼界 永远不要指望有人会明白你在说什么，别相信什么切肤之痛，别相信什么感同身受，你就是你，独一无二的你，你的那些情绪、想法、念头，别人无法感知，亦无法理解。 —— 独木舟","text":"那些动听的想法如果不能趁年轻易感的时候去实现，消逝的速度比云还快。 即使有人告诉我，山的那边还是山，我依然想一路小跑翻山越岭，亲自感慨：“我靠！他说的是真的诶！” 与天地等量齐观的眼界 永远不要指望有人会明白你在说什么，别相信什么切肤之痛，别相信什么感同身受，你就是你，独一无二的你，你的那些情绪、想法、念头，别人无法感知，亦无法理解。 —— 独木舟 佛曰，人生有八苦：生，老，病，死，爱别离，怨长久，求不得，放不下。 佛曰：命由己造，相由心生，世间万物皆是化相，心不动，万物皆不动，心不变，万物皆不变。 佛曰：坐亦禅，行亦禅，一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静体自然。 佛说：万法皆生，皆系缘份，偶然的相遇，暮然的回首，注定彼此的一生，只为眼光交汇的刹那。 缘起即灭，缘生已空。 这不是你梦寐以求的长大吗，你怎么愁眉不展？– 别辜负 你恋爱了，只是你爱的人，有时并不真的存在。他可能只是一堵无辜的白墙，被你狂热的，把你心里最向往的爱情电影，全部在他身上投影一遍。 因为我刚才看到你，觉得你挺可爱的，但我不知道该不该跟你搭讪，所以我问自己，我该不该认识她呢？答案是，我没有理由不去认识她。 朋友，记住一条简单的惯性定律:静止的倾向于静止，运动的倾向于运动。不知道一件事情怎么开始才合适？先去做10分钟。不知道怎么和女孩搭讪？立马过去说一声:“你好！……”后面的你自然会接着说。动起来，运动的倾向于运动。 父母所想永远是避免子女受到伤害，而子女所想永远是如何才能不枉此生。这场博弈注定有一方让步，一方喜笑颜开。 未来一百年乃至一千年一万年，很难看到强人工智能的出现。因为人类对智能本质的了解其实太少了。无知者无畏，正因为我们的肤浅，所以才盲目的乐观，“人工智能的奇点”出现在2050年根本就是无稽之谈。人类目前靠有限的一点数学算法对智能死板的模拟，比大自然的精巧的进化创造，简直是天壤之别。套用别人对“深度学习”算法的评价：“梯子很长，但还远远够不到月亮”。— Daniel 快乐分享错了人，成为了炫耀，难过分享错了人，成了矫情。 以前觉得，年少时的喜欢不算什么，长大以后，还有许多壮阔的温柔在前方。但其实并不是这样，年少时的喜欢其实浓度最高，高到你以为你不在乎不喜欢了，其实关于喜欢的细枝末节都深深地扎根在心里，以至于以后遇到的所有人，都比不上当初的那个男孩或女孩所带来的心动。 所以啊，如果再遇见你，我不想给自己留下遗憾。 人们总是对喜欢的人不说我喜欢你 却说我想你对想见的人不说我想你 却说要不要一起吃个饭 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。 曾经我自诩半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。唯独见了你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。— 网易云音乐《起风了》热评 浮萍漂泊本无根 天涯游子君莫问 妙龄聪俊风流子 堪配西凉窈窕娘","categories":[{"name":"favwords","slug":"favwords","permalink":"http://blogzhou.top/categories/favwords/"}],"tags":[{"name":"Words","slug":"Words","permalink":"http://blogzhou.top/tags/Words/"}]},{"title":"My Words","slug":"p05.MyWords","date":"2018-03-07T10:32:41.000Z","updated":"2020-07-18T03:20:22.674Z","comments":true,"path":"2018/03/07/p05.MyWords/","link":"","permalink":"http://blogzhou.top/2018/03/07/p05.MyWords/","excerpt":"","text":"为了锦绣前程也好，花样人生也罢，然而，还是恨透了 别离。 长大，淡然了许多事，唯别离愈发的难以释怀。","categories":[{"name":"favwords","slug":"favwords","permalink":"http://blogzhou.top/categories/favwords/"}],"tags":[{"name":"Words","slug":"Words","permalink":"http://blogzhou.top/tags/Words/"}]},{"title":"胡乱写写(My poetry)","slug":"p03.My-poetry（胡乱写写）","date":"2017-10-25T03:28:21.000Z","updated":"2020-07-18T03:20:22.697Z","comments":true,"path":"2017/10/25/p03.My-poetry（胡乱写写）/","link":"","permalink":"http://blogzhou.top/2017/10/25/p03.My-poetry（胡乱写写）/","excerpt":"远方 我来自哪里又将去向何方 满地的油菜花一望无际花海和天相接的地方是怎样一副景象 微风轻抚花儿轻摇 听有个声音在轻唤远方远方","text":"远方 我来自哪里又将去向何方 满地的油菜花一望无际花海和天相接的地方是怎样一副景象 微风轻抚花儿轻摇 听有个声音在轻唤远方远方 秋日初醒 清晨、初醒、微凉迷茫、迷茫、迷茫总是憧憬诗与远方但却不知如何前往入世三年有余不知前路何方时职实非吾志追梦又恐寒霜奈何格局所限只能困于这方将近而立之年身家三三两两父母意不可辜自身志不可负世间安有全法叫我谁都不负性本秋田南山却处在这红尘俗世间时下且顾眼前但愿不负明天 晚霞迎夜幕，手握相思土。往事一幕幕，而今你何处。 那年的初遇 在那落叶纷飞的季节在那初来乍到的校角在那冷冷清清的球场边在那历经沧桑的栅栏旁 你无意的回首映入眼帘的是那绝美的容颜 那双会笑的眼睛融化了秋日的寒霜春风拂面 如风陵渡口的初遇似得见面具下俊俏脸庞的郭襄你唤醒了我沉睡已久的悸动 从此校园里多了一双寻觅的眼睛世间多了一个相思的少年 你装点了我如梦的思念陪伴了我匆匆的那年 你给了我一场完美的邂逅让我明白什么是止于唇齿的爱恋 飞逝的四年定格的画面 它揉碎在记忆的长河里滋润着流年 玉来 玉楼窗旁桃花面，来去偏偏杨柳姿。是非对错红尘怨，女儿心思几人识。妆罢镜中妩媚娘，大可倾尽北国郎。老幼得见皆倾心，阿飞初识犹猖狂！ 啦啦啦 情言多矫揉做作人情深迷失自我节度失痴男怨女快愉寄霞友云朋乐情托北窗之友 随笔（1） 午夜梦回有你有我清晨初醒独望寒窗 随笔（2） 窗外的雨淅淅沥沥敲打着玻璃恍如昨日真的好像好像只是少了听雨的你 不见 人生因缺憾而完美不见也好至少在自我构建的王国中你永不会褪色 《傻傻的我》 我以为真的是因为怕生真的是需要慎重可你信一见钟情 我以为真的是因为季节真的是畏惧北风可我于你就是北风你等的不是吹南风的季节你等的是能让你沐浴南风的人 我以为真的能蹭一顿饭真的是想想就激动可女人都是骗子我能咋整。。。 看这傻傻的我 因果 前世的因今生的果一定是我前世与你的回眸不够今生才只能与你相忘于江湖 If I like you,I will take a few steps to your direction forwardly and a few more,if you see me coming and respond by nothing,I will stop.There are so many things in the world that we can get by fighting hard,but only for love,I don’t wanna try so hard.Two well-matched persons,fair and equal love and being loved.Live in such a rat-race kind of world,I wish I can get one love without trying too damn hard. 流年 总以为这一秒和上一秒没什么不同；总以为岁月不会如此匆匆；总以为自己still a little boy；……可这蓦然的回首，时间磨平了棱角，岁月消逝了朱颜。 —&gt;18.3.7 三尺微命一介布衣寄身于这天地间尚不能顾全自身冷暖凭何立室成家 其实人生一世草木一秋有什么区别呢横竖都是一一生一死一场空可又确乎有区别草木较人活的认真的多草木虽一秋她记住了南风初暖她记住了骄阳似火她记住了露莹枝头她记住了凛凛北风。。。她不去证明什么也不必证明什么她来过用心的感受这世界她走了带着满足可人呢它一直在赶路一直在追寻一直盯着遥不可及的一直执着于得不到的它拼命在证明什么可真正在追寻什么想证明什么几人能说的清楚到头来站在生命的尽头什么都没剩下只有一身疲惫就这么浑浑噩噩的去了 好不容易来这世上走一遭终归是可惜了些 等你 我这个人啊这二十几年不缺春日的莺歌燕舞，虫鸣鸟啼不缺夏日的骄阳似火，蚊叮蝉扰不缺秋日的稻黄百里，黍谷飘香不缺冬日的银装素裹，雾凇沆砀唯独缺个你 陪我见证这一切啊","categories":[{"name":"My poetry","slug":"My-poetry","permalink":"http://blogzhou.top/categories/My-poetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"如何清理XCode缓存","slug":"t09.如何清理XCode缓存","date":"2017-10-23T06:12:44.000Z","updated":"2020-07-18T03:20:22.690Z","comments":true,"path":"2017/10/23/t09.如何清理XCode缓存/","link":"","permalink":"http://blogzhou.top/2017/10/23/t09.如何清理XCode缓存/","excerpt":"原文链接 一：移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData) 只要重新运行Xcode就一定会重新生成，而且会随着运行程序的增多，占用空间会越来越大。删除后在重新运行程序可能会稍微慢一点，建议定期清理。 路径： 1~/Library/Developer/Xcode/DerivedData","text":"原文链接 一：移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData) 只要重新运行Xcode就一定会重新生成，而且会随着运行程序的增多，占用空间会越来越大。删除后在重新运行程序可能会稍微慢一点，建议定期清理。 路径： 1~/Library/Developer/Xcode/DerivedData 二：移除 APP 打包的ipa历史版本(Archives) 删除后不可恢复，文件夹是按照日期排列的，所以如果你不想全部删除，就只保留最新的几个版本就好了，个人建议全部删除。 路径： 1~/Library/Developer/Xcode/Archives 三：移除 APP 打包的app icon历史版本(Archives) 删除后不可恢复，文件夹是Bundle Idenifier排列的，然后再按照archive的版本号排列的，如果你看每个版本内的内容，其实就是你的app icon，个人建议全部删除。 路径： 1~/Library/Developer/Xcode/Products/ 四：移除模拟器的缓存数据(Devices) 模拟器的相关数据。每个版本的模拟器占用的内存空间大约为10M左右。每个文件夹里包含的就是一个特定系统版本的设备的数据。每个文件夹对应哪个设备可以在其下device.plist中查看。删除之后，如果立即运行程序会报错，先关闭Xcode，再重新打开程序，运行即可。运行该路径下会立马生成模拟器对应版本的文件。 路径： 1~/Library/Developer/CoreSimulator/Devices/ 五：移除对旧设备的支持(iOS DeviceSupport) 一般是占用内存空间最大的文件夹，即使全部删，再连接设备调试时，会重新自动生成。一般iOS只向下兼容两个版本就可以了，所以我移除了9.0以下的所有版本。 路径： 1~/Library/Developer/Xcode/iOS DeviceSupport 六：移除 Xcode 中的无效的插件(Plug-ins) 因为之前你可能安装了一些 Xcode 的插件，比如HighlightSelectedString、VVDocumenter-Xcode等非常方便好用的第三方插件，在Xcode升级到version 8.0以后，就失效了，Xcode在内部已经集成了类似的方法，所以之前安装的也都没有用了，但是还在原来的位置占用着内存空间，建议删除。 路径： 12//如果你曾经没有安装过插件，那么可能不存在此路径。~/Library/Application Support/Developer/Shared/Xcode/Plug-ins 七：移除旧版本的模拟器支持 如果你不小心安装了很多个版本的模拟器，那么你可以删除一些旧版本的。但是当你需要旧版本的模拟器时，就需要重新下载了。建议留下1~2个版本就好了，其余的都删了吧。 路径： 1~/Library/Developer/CoreSimulator/Profiles/Runtimes/ 八：移除 playground 的项目缓存(XCPGDevices) 删除后可重新生成，可以全部删除。再次运行程序会缓存。 路径： 1~/Library/Developer/XCPGDevices/ 九：移除旧的文档(Docsets) 删除后不可恢复，该目录下存储的为开发文档，一般有三个文件com.apple.adc.documentation.iOS.docset(1.68GB)、com.apple.adc.documentation.OSX.docset(2.62GB)和com.apple.adc.documentation.Xcode.docset(256.4M)，如果你只做iOS开发，其实你可以把OSX.docset删除掉的，因为它占用了2.62GB的内存。 路径： 1~/Library/Developer/Shared/Documentation/DocSets 十：移除模拟器中的SDK版本(iPhoneSimulator.sdk) 不可恢复，操作请慎重。我个人的此路径下的只有最新版本的sdk，除非当你有多个版本的sdk再酌情删除。 路径： 12//注意：占用空间约4GB，删除时请慎重~/application/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/ By the way: 前往文件夹快捷键：Command + shift + G Xcode清除最近打开的文件列表：File -&gt; Open Recent -&gt; Clear Menu","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"XCode","slug":"XCode","permalink":"http://blogzhou.top/tags/XCode/"}]},{"title":"诗歌（inland）","slug":"p01.诗歌（inland）","date":"2017-10-17T02:01:48.000Z","updated":"2020-07-18T03:20:22.698Z","comments":true,"path":"2017/10/17/p01.诗歌（inland）/","link":"","permalink":"http://blogzhou.top/2017/10/17/p01.诗歌（inland）/","excerpt":"《可遇不可求的事》— 冯唐后海有树的院子夏代有工的玉此时此刻的云二十来岁的你 故乡的云，上古的玉，随手的诗，此刻的你。","text":"《可遇不可求的事》— 冯唐后海有树的院子夏代有工的玉此时此刻的云二十来岁的你 故乡的云，上古的玉，随手的诗，此刻的你。 《致橡树》— 舒婷我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 《雨巷》—戴望舒撑着油纸伞，独自彷徨在悠长，悠长又寂寥的雨巷，我希望逢着一个丁香一样的结着愁怨的姑娘。她是有丁香一样的颜色，丁香一样的芬芳，丁香一样的忧愁，在雨中哀怨，哀怨又彷徨；她彷徨在这寂寥的雨巷，撑着油纸伞像我一样，像我一样地默默彳亍着，冷漠，凄清，又惆怅,她静默地走近走近，又投出太息一般的眼光，她飘过像梦一般的，像梦一般的凄婉迷茫。像梦中飘过一枝丁香的，我身旁飘过这女郎；她静默地远了，远了，到了颓圮的篱墙，走尽这雨巷。在雨的哀曲里，消了她的颜色，散了她的芬芳消散了，甚至她的太息般的眼光，丁香般的惆怅,撑着油纸伞，独自彷徨在悠长，悠长又寂寥的雨巷，我希望飘过一个丁香一样的结着愁怨的姑娘。 《再别康桥》—徐志摩轻轻的我走了，正如我轻轻的来；我轻轻的招手，作别西天的云彩。 那河畔的金柳，是夕阳中的新娘；波光里的艳影，在我的心头荡漾。 软泥上的青荇,油油的在水底招摇,在康河的柔波里，我甘心做一条水草！ 那榆荫下的一潭，不是清泉，是天上虹；揉碎在浮藻间，沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯,满载一船星辉，在星辉斑斓里放歌。 但我不能放歌，悄悄是别离的笙箫；夏虫也为我沉默，沉默是今晚的康桥！ 悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一片云彩。 一个人需要隐藏多少秘密才能巧妙地度过一生这佛光点点的高原三步两步便是天堂却仍有那么多人因心事过重而走不动—仓央嘉措","categories":[{"name":"favpoetry","slug":"favpoetry","permalink":"http://blogzhou.top/categories/favpoetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"诗歌（foreign）","slug":"p02.诗歌（foreign）","date":"2017-10-16T02:40:45.000Z","updated":"2020-07-18T03:20:22.697Z","comments":true,"path":"2017/10/16/p02.诗歌（foreign）/","link":"","permalink":"http://blogzhou.top/2017/10/16/p02.诗歌（foreign）/","excerpt":"《I Strove with None》— Walter Savage Landor I strove with none,for none was worth my strife;Nature I lov’d, ，and next to Nature, Art;I warm’d both hands before the fire of life;It sinks,and I am ready to depart. 我和谁都不争，和谁争我都不屑；我爱大自然，其次就是艺术；我双手烤着，生命之火取暖；火萎了，我也准备走了。——[英]兰德（杨绛 译）","text":"《I Strove with None》— Walter Savage Landor I strove with none,for none was worth my strife;Nature I lov’d, ，and next to Nature, Art;I warm’d both hands before the fire of life;It sinks,and I am ready to depart. 我和谁都不争，和谁争我都不屑；我爱大自然，其次就是艺术；我双手烤着，生命之火取暖；火萎了，我也准备走了。——[英]兰德（杨绛 译） 《When You Are Old》— William Butler YeatsWhen you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes had once, and of their shadows deep;How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face;And bending down beside the glowing bars,Murmur, a little sadly, how love fledAnd paced upon the mountains overheadAnd hid his face amid a crowd of stars. 《当你老了》袁可嘉译当你老了，头白了，睡思昏沉在炉火旁打盹，请取下这部诗歌慢慢读，回想你过去眼神的柔和回想它们昔日浓重的阴影多少人爱你青春欢畅的时辰爱慕你的美丽，假意或真心只有一个人爱你朝圣者的灵魂爱你衰老了的脸上痛苦的皱纹垂下头来，在红火闪耀的炉子旁凄然地轻轻诉 说那爱情的消逝在头顶上的山上它缓缓地踱着步子在一群星星中间隐藏着脸庞","categories":[{"name":"favpoetry","slug":"favpoetry","permalink":"http://blogzhou.top/categories/favpoetry/"}],"tags":[{"name":"poetry","slug":"poetry","permalink":"http://blogzhou.top/tags/poetry/"}]},{"title":"iOS系统音量&屏幕亮度调节","slug":"t06.iOS系统音量-屏幕亮度调节","date":"2017-10-12T07:35:14.000Z","updated":"2020-07-18T03:20:22.693Z","comments":true,"path":"2017/10/12/t06.iOS系统音量-屏幕亮度调节/","link":"","permalink":"http://blogzhou.top/2017/10/12/t06.iOS系统音量-屏幕亮度调节/","excerpt":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125;","text":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125; 监听系统物理按键调节音量12345678910/** 监听 */- (void)registerVolumeChangeEvent &#123;// NSError *error;// [[AVAudioSession sharedInstance] setActive:YES error:&amp;error]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeVolumeValueFunc) name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125;/** 移除 */- (void)unregisterVolumeChangeEvent &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125; 获取系统当前音量1[[AVAudioSession sharedInstance] outputVolume]; 二，屏幕亮度很简单就一句 123456789[[UIScreen mainScreen] setBrightness:值（0 ~ 1）]//示例 if (panPoint.y &lt; 0) &#123; //增加亮度 [[UIScreen mainScreen] setBrightness:self.startVB + (-panPoint.y / 30.0 / 10)]; &#125; else &#123; //减少亮度 [[UIScreen mainScreen] setBrightness:self.startVB - (panPoint.y / 30.0 / 10)]; &#125;","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"UIButton重复点击解决方案","slug":"t04.UIButton重复点击解决方案","date":"2017-10-12T07:33:26.000Z","updated":"2020-07-18T03:20:22.694Z","comments":true,"path":"2017/10/12/t04.UIButton重复点击解决方案/","link":"","permalink":"http://blogzhou.top/2017/10/12/t04.UIButton重复点击解决方案/","excerpt":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0;","text":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0; 2.声明一个方法及实现如下（思路很简单就直接上代码了）1234567891011121314/** * 根据传过来的时间间隔进行是否快速点击判断； * opIntervalTime ： 时间间隔，单位毫秒； **/+(bool)isFastDoubleClick1:(long)opIntervalTime&#123; NSDate* date = [NSDate dateWithTimeIntervalSinceNow:0]; long time = [date timeIntervalSince1970] * 1000; long intervalTime = time - LAST_CLICK_TIME1; if(0 &lt; intervalTime &amp;&amp; intervalTime &lt; opIntervalTime)&#123; return true; &#125; LAST_CLICK_TIME1 = time; return false;&#125; 参数说明注释写得很清楚，用法也很简单，就不多说了。 方式二（较主流）给UIButton写个分类（category）1.分类.h文件 12345#import &lt;UIKit/UIKit.h&gt;@interface UIButton (FMExtension)/** 两次点击最大时间间隔，在此时间内，所有点击事件不不执行 */@property (nonatomic, assign) NSTimeInterval fm_multipleClickInterval;@end 由于category 中声明的property，只会生成属性的方法而不会生成方法的实现及“_”变量，所以.m中要用runtime进行属性的动态绑定。2.分类.m 文件具体实现步骤2.1引入runtime头文件 12345678910#import &quot;UIButton+FMExtension.h&quot;#import &lt;objc/runtime.h&gt;@interface UIButton ()/** 记录上一次接收点击事件的时间 */@property(nonatomic, assign) NSTimeInterval fm_acceptEventTime;@end/** 关联关键字 */static const char *UIControl_multipleClickInterval = &quot;fm_multipleClickInterval&quot;;static const char *UIControl_acceptEventTime = &quot;fm_acceptEventTime&quot;;@implementation UIButton (FMExtension) 2.2动态关联对象1234567891011121314/** 动态关联对象 */- (void)setFm_multipleClickInterval:(NSTimeInterval)fm_multipleClickInterval &#123; //四个参数：源对象，关键字，关联的对象和一个关联策略 objc_setAssociatedObject(self, UIControl_multipleClickInterval, @(fm_multipleClickInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_multipleClickInterval &#123; return [objc_getAssociatedObject(self, UIControl_multipleClickInterval) doubleValue];&#125;- (void)setFm_acceptEventTime:(NSTimeInterval)fm_acceptEventTime &#123; objc_setAssociatedObject(self, UIControl_acceptEventTime, @(fm_acceptEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_acceptEventTime &#123; return [objc_getAssociatedObject(self, UIControl_acceptEventTime) doubleValue];&#125; 2.3交换方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//交换方法//以上主要是实现两个方法的互换,load是gcd的只shareinstance，果断保证执行一次+ (void)load &#123; //获取着两个方法 //系统方法 Method sysMethod = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:)); SEL sysM = @selector(sendAction:to:forEvent:); //自定义方法 Method myMethod = class_getInstanceMethod(self, @selector(fm_sendAction:to:forEvent:)); SEL myM = @selector(fm_sendAction:to:forEvent:); //添加方法进去（系统方法名执行自己的自定义函数，相当于重写父类方法） BOOL overrideSuccess = class_addMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); //如果添加成功 if (overrideSuccess) &#123; //自定义函数名执行系统函数 class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); &#125; else &#123; method_exchangeImplementations(sysMethod, myMethod); &#125; //这样也可以交换方法（但是注意顺序） /****** * *个人理解： *不管是add还是replace和系统重名的方法，都是相当于复制了一个和系统重名的函数（也就是 *相当于继承重写了父类方法 ps:分类中不支持继承！系统发现有这个方法会优先调用） *系统自动复制一个与自己同名的方法给开发人员用，但是method_getImplementation(systemMethod) *还是获取系统自带方法的属性 * ******/ /* class_replaceMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); */&#125;- (void)fm_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; if (NSDate.date.timeIntervalSince1970 - self.fm_acceptEventTime &lt; self.fm_multipleClickInterval) return; if (self.fm_multipleClickInterval &gt; 0) &#123; self.fm_acceptEventTime = NSDate.date.timeIntervalSince1970;//记录上次点击的时间 &#125; //这里并不是循环调用，由于交换了两个方法，fm_sendAction:to:forEvent:现在就是sendAction:to:forEvent: [self fm_sendAction:action to:target forEvent:event];&#125;@end 代码注释写的比较详细了（自我感觉还阔以吧），就不再多说什么。PS: 交换方法那，有个人的一点小小见解，不知道对不对，欢迎大牛批评指正！！！","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"类似“今日头条”频道编辑功能UI实现","slug":"t07.类似“今日头条”频道编辑功能UI实现","date":"2017-10-12T07:32:08.000Z","updated":"2020-07-18T03:20:22.693Z","comments":true,"path":"2017/10/12/t07.类似“今日头条”频道编辑功能UI实现/","link":"","permalink":"http://blogzhou.top/2017/10/12/t07.类似“今日头条”频道编辑功能UI实现/","excerpt":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅）","text":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅） 之所以用着两位前辈的代码，是因为，虽然实现是同一UI效果，但是思路不同，下面一一讲解方式一：(对应前辈一的实现思路) 思路：完全自定义。自定义channelView（项目中名称：TouchView）继承于UIView,绑定需要的label，imageView，pan,tap,longPress手势，在对应的手势实现中计算出每个channel的index，然后刷新frame（具体实现请参考代码） 优点：自定义程度高，自定义功能的添加修改比较方便，尤其动画比较流畅； 缺点：要同时处理四个数组的数据（两个数据源的，两个视图的），frame刷新频率较高，且都是自己实现的frame刷新，性能可能不如原生的控件（只是可能） 我的完善：原框架功能已经比较完善，只是缺少个下滑移除功能（已添加） GIF效果图： 方式二：(对应前辈二的实现思路) 思路：在UICollectionView的基础上进一步的修改封装。（具体实现请参考代码） 优点：只需要处理两个数据源就可以（上部&amp;下部），视图由UICollectionView自己处理，包括动画效果也是系统自己完成； 缺点：基于UICollectionView，功能的拓展受到一定的限制，动画不如方式一看这舒服。 我的完善：原框架功能较少（相对于今日头条的channel编辑效果），只有上部分的排序和删除。（下部及其他功能已添加） GIF效果图： 其他功能 标题内容对应滑动，滑动后标题居中 标题随滑动，字体大小变化 子视图内，有颜色渐变小Demo GIF效果图： QQ Popover弹框效果GIF效果图： Demo下载","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"UICollectionView下拉刷新闪一下问题解决","slug":"t03.UICollectionView下拉刷新闪一下问题解决","date":"2017-10-12T07:31:08.000Z","updated":"2020-07-18T03:20:22.695Z","comments":true,"path":"2017/10/12/t03.UICollectionView下拉刷新闪一下问题解决/","link":"","permalink":"http://blogzhou.top/2017/10/12/t03.UICollectionView下拉刷新闪一下问题解决/","excerpt":"","text":"最近写项目遇到UICollectionView的下拉刷新数据回来时，屏幕会闪一下，在网上找了几个方法，亲自试了都不好使，后来自己试了下回主线程刷新UI，发现可以，代码如下:123dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView reloadData]; &#125;); 大家都知道，在子线程刷新UI是很危险的，有时会出现莫名的Bug, 有些情况甚至会直接崩溃。而网络数据的请求一般都是在子线程进行的，数据回来时去刷新UI（UITableView 和 UIConllectionView）但是UITableView在子线程刷新UI没有出现这个Bug（估计苹果做了优化）。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"WYYKTScroll控件悬停","slug":"t02.WYYKTScroll控件悬停","date":"2017-10-12T07:25:30.000Z","updated":"2020-07-18T03:20:22.695Z","comments":true,"path":"2017/10/12/t02.WYYKTScroll控件悬停/","link":"","permalink":"http://blogzhou.top/2017/10/12/t02.WYYKTScroll控件悬停/","excerpt":"效果示例 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果","text":"效果示例 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果 1.工程引入FMBaseViewController, 并添加要自定义的controller 有关头部image及button的相关设置通过，FMBaseViewController的属性进行设置，示例代码如下：123456789FMBaseViewController *bvc = [[FMBaseViewController alloc] init];bvc.btnBackColor = [UIColor cyanColor];bvc.btnTitleArr = @[@&quot;张三&quot;, @&quot;李四&quot;, @&quot;王五&quot;];bvc.indicatorColor = [UIColor yellowColor];bvc.isIndicatorHidden = YES;bvc.headImage_H = 100;bvc.button_H = 30;bvc.headImageName = @&quot;picture_3&quot;;bvc.isStretch = NO; 2.注意：自定义的controller 必须继承于FMParentViewController.h, 并且子控制器暂时只支持UITableViewController 子控制器类型1 ：FMTableViewStylePlain 初始化代码如下： 123FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStylePlain];或者（default）FMT1ViewController *t1 = [[FMT1ViewController alloc] init]; 子控制器类型2：FMTableViewStyleGroup 初始化代码如下： 1234FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];或者（用属性修改）FMT1ViewController *t2 = [[FMT1ViewController alloc] init];t2.tableViewStyle = FMTableViewStyleGrouped; 3.头部视图是否可以拉伸： 1isStretch 属性（default is YES） 测试效果查看，在AppDelegate.m 的launch函数中添加（或替换）如下代码： 123FMBaseViewController *bvc = [[FMBaseViewController alloc] init]; self.window.rootViewController = bvc; [self.window makeKeyAndVisible]; 自定义子controller初始化后传入该数组childVCArr，示例代码如下： 12345FMBaseViewController *bvc = [[FMBaseViewController alloc] init];FMT1ViewController *t1 = [[FMT1ViewController alloc] init];FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];FMT3ViewController *t3= [[FMT3ViewController alloc] init];bvc.childVCArr = @[t1, t2, t3]; ####子控制器最好不要超过5个， 暂不支持滑动（以后可能添加，敬请期待！） headView上的内容可自定义添加，通过 ftc.headView可拿到head部分的视图添加自己的控件。 支持cocoaPods 安装 1234pod search WYTest在Podfile中添加pod &quot;WYTest&quot;pod install || pod update ###2018.08.01更新 ####增加对UICollectionView的支持，controller必须继承自FMBaseCollectionViewController 示例代码 1234FMT1ViewController *t1 = [[FMT1ViewController alloc] init];t1.tableViewStyle = FMTableViewStyleGrouped;FMC1ViewController *c1 = [[FMC1ViewController alloc] init];FMT3ViewController *t3= [[FMT3ViewController alloc] init]; 效果示例 - 全collectionView 效果示例 - collectionView 和 tableView混合 ##github Demo下载地址点击去下载","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://blogzhou.top/tags/UI/"}]},{"title":"如何利用pod trunk发布程序","slug":"t01.如何使项目支持cocoaPods","date":"2017-10-11T06:16:01.000Z","updated":"2020-07-18T03:20:22.696Z","comments":true,"path":"2017/10/11/t01.如何使项目支持cocoaPods/","link":"","permalink":"http://blogzhou.top/2017/10/11/t01.如何使项目支持cocoaPods/","excerpt":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息","text":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: MJ Lee- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec create 文件名 比如pod spec cretae MJExtension就会生成一个MJExtension.podspec 填写podspec内容1234567891011121314Pod::Spec.new do |s| s.name = &quot;MJExtension&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/CoderMJLee/MJExtension&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;MJLee&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/CoderMJLee/MJExtension.git&quot;, :tag =&gt; s.version &#125; s.frameworks = &quot;UIKit&quot;, &quot;Foundation&quot; s.platform = :ios, &quot;8.0&quot; s.source_files = &quot;MJExtensionExample/MJExtensionExample/MJExtension&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint MJExtension.podspec 发布podspec pod trunk push MJExtension.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.gitpodspec 更新版本步骤 1.代码修改 2.修改podspec文件中的version 版本号 3.git tag (后跟版本号)&amp; git push —-tags同步远程仓库版本号 4.将本地的代码提交远程仓库（更新版本号） 5.pod trunk push xxx.podspec 提交最新的podspec文件 注意：提交的代码里最好不要有警告","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://blogzhou.top/tags/tool/"}]},{"title":"文件流、网络操作、服务端Web开发基础","slug":"old_10.文件流、网络操作、服务端Web开发基础","date":"2017-01-20T12:30:50.000Z","updated":"2020-12-16T08:04:20.789Z","comments":true,"path":"2017/01/20/old_10.文件流、网络操作、服务端Web开发基础/","link":"","permalink":"http://blogzhou.top/2017/01/20/old_10.文件流、网络操作、服务端Web开发基础/","excerpt":"","text":"文件操作文件监视利用文件监视实现自动 markdown 文件转换 相关链接： https://github.com/chjj/marked https://github.com/Browsersync/browser-sync 实现思路： 利用fs模块的文件监视功能监视指定MD文件 当文件发生变化后，借助marked包提供的markdown to html功能将改变后的MD文件转换为HTML 再将得到的HTML替换到模版中 最后利用BrowserSync模块实现浏览器自动刷新browsersync需要用到Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fs = require('fs');const path = require('path');var marked = require('marked');var bs = require('browser-sync').create();var target = path.join(__dirname, process.argv[2] || './README.md');var filename = path.basename(target, path.extname(target)) + '.html';var targetHtml = path.join(path.dirname(target), filename);bs.init(&#123; server: path.dirname(target), index: filename, notify: false&#125;);bs.reload(filename);var template = `&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;article class=\"markdown\"&gt; &#123;&#123;&#123;body&#125;&#125;&#125; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt;`;fs.readFile(path.join(__dirname, './markdown.css'), 'utf8', (error, css) =&gt; &#123; if (error) throw error; template = template.replace('&#123;&#123;&#123;styles&#125;&#125;&#125;', css); var handler = (current, previous) =&gt; &#123; fs.readFile(target, 'utf8', (error, content) =&gt; &#123; var html = template.replace('&#123;&#123;&#123;body&#125;&#125;&#125;', marked(content)); fs.writeFile(targetHtml, html, (error) =&gt; &#123; if (!error) &#123; console.log(`updated@$&#123;new Date()&#125;`); bs.reload(filename); &#125; &#125;); &#125;); &#125;; handler(); fs.watchFile(target, &#123; interval: 100 &#125;, handler);&#125;); 文件流什么是流 现实过程的流 水流，人流 在程序开发的概念中 流是程序输入或输出的一个连续的字节序列 文件流、网络流 设备(例如鼠标、键盘、磁盘、屏幕、调制解调器和打印机)的输入和输出都是用流来处理的。 Node中的流操作 在 Node 核心模块 fs 中定义了一些与流相关的 API fs.createReadStream() =&gt; 得到一个ReadableStream fs.createWriteStream() =&gt; 得到一个WritableStream 读取流常用 APIEvent： data end error Method： read([size])、 pause()、 isPause()、 resume()、 setEncoding(encoding)、 pipe(destination[, options])、 unpipe([destination]) 写入流常用 APIEvent: error pipe Method： write(chunk[, encoding][, callback]) end([chunk][, encoding][, callback]) setDefaultEncoding(encoding) 网络操作如何计算循环节长度呢？ 想想我们手算，如果余数比除数小，我们会在后面补0然后再除。也就是说补零之后的数是下一次的被除数。如果被除数重复出现，除数确定的，那么商和余数也就是一样的。这时，循环节就出现了。 下面的函数分为两部分， 补零操作查找有没有同样的被除数存在，如果有，就找到了循环节，计算循环节长度并返回。在没有找到的前提下，把当前被除数记录下来，并得到余数作为下一次的被除数。这里需要注意，如果某一次出现了除尽的情况，说明该分数是有限小数，循环节长度是0。JavaScript123456789101112131415161718192021222324252627282930console.log(foo(11, 3)); console.log(foo(1, 7));; console.log(foo(2, 10));; function foo(a, b) &#123; if (!(a % b)) &#123; return `$&#123;a&#125;÷$&#123;b&#125;:$&#123;a / b&#125;`; &#125; var all = (a / b).toString().split(&apos;.&apos;); var i = getCycleSection(a, b); if(i) return `$&#123;a&#125;÷$&#123;b&#125;: $&#123;all[0]&#125;.&#123;$&#123;all[1].substr(0, i) &#125;&#125;`; return `$&#123;a&#125;÷$&#123;b&#125;: $&#123;a / b&#125;`;&#125;function getCycleSection(n, m) &#123; var temp = []; while (true) &#123; while (n &lt; m) &#123; n *= 10; &#125; var index = temp.indexOf(n); if (index &gt;= 0) &#123; return temp.length - index; &#125; temp.push(n); n %= m; if (!n) return 0; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson6","slug":"old_09.node-lesson6","date":"2016-12-28T12:30:50.000Z","updated":"2020-12-16T07:54:46.324Z","comments":true,"path":"2016/12/28/old_09.node-lesson6/","link":"","permalink":"http://blogzhou.top/2016/12/28/old_09.node-lesson6/","excerpt":"node-lesson6复习1.1复习网络编程 什么是网络编程 使用 node 进行网络编程需要使用其它web服务器作为容器吗 什么是协议？什么是http协议？ 在网络编程中，为什么要有协议？制定协议有什么好处？ 1.2 http协议","text":"node-lesson6复习1.1复习网络编程 什么是网络编程 使用 node 进行网络编程需要使用其它web服务器作为容器吗 什么是协议？什么是http协议？ 在网络编程中，为什么要有协议？制定协议有什么好处？ 1.2 http协议 1.3session&amp;cookie网站的优化—–&gt;思想12345671.能压缩的压缩能合并的合并少一个script也好，少一次请求 2.少用js去遍历对象或者写for循环3.能提前运算好的提前运算好，使用枚举法 var a=1024*1024;4.cdn5.响应式图片~~~~图片压缩 1.4 工具的使用通过 nodemon 实现 保存文件实时重启 安装nodemon npm install -g nodemon 基本使用 nodemon server.js 只要执行了上面的命令，那么当你修改了 server.js 那么nodemon会帮你自动重启 server ###2.1 使用npm命令执行代码1.package.json里面配置scripts属性里面写npm的命令2.npm的命令在控制台直接npm打印出来可以查看3.npm命令后面接的是具体的命令，打npm命令调用具体的命令 ###2.2编写node脚本1.把js代码变成node脚本在要执行的js文件当中加入下面这句话，是固定写法 #!/usr/bin/env node 2.package.json里面配置bin属性里面写命令,这个命令的名称是可以自定义的 3.必须打npm link这个命令，把当前包安装到全局去 ###2.3通过命令调用脚本 http 模块使用 http 模块进行web开发localhost:3000 不走网卡127.0.0.1:3000 走网卡192.168.141.XXX 通过网卡发请求给路由或交换机，在请求回来你的电脑 创建 HTTP 服务器 http.createServer([requestListener]) 通过监听Event: ‘request’来进行server.on(‘request’,(request,response) =&gt; {}); request、response对象request对象，用于接收请求报文内的信息response对象，用于返回响应报文内的信息 response.write()write方法用于向响应体里写内容，用于向客户端发送信息，可以被多次使用 response.end()在一次请求和响应过程当中，只要调用了 end 就不能再继续 write 了就说明你是在一次请求和响应处理过程中已经结束了响应，但是又去 向客户端发送数据这个时候就会报错 server.listen(port[, hostname][, backlog][, callback])监听端口，执行这句，服务正式被启动使用server.listen(3000,’127.0.0.1’,() =&gt; {console.log(‘server is listening at port 3000’);}); request request.headers 请求头 request.method 请求方法 request.url 请求路径 request.httpVersion 请求HTTP协议版本 response res.writeHead(200,{‘Content-Type’: ‘text/html; charset=utf-8’});设置响应报文头 res.write(‘hello world‘); res.end(); Content-Type内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文 通过 req.url和req.method的不同给出不同的响应 if (req.url == ‘/‘ &amp;&amp; req.method == ‘GET’) { res.writeHead(200, { ‘Content-Type’: ‘text/html; charset=utf-8’ }); res.write(‘首页‘); res.end(); } request通过data事件和end事件来接收post的数据let data = ‘’;req.on(‘data’, (chunk) =&gt; { data += chunk;}); req.on(‘end’, () =&gt; { console.log(data); res.writeHead(200, { ‘Content-Type’: ‘text/html; charset=utf-8’ }); res.write(‘收到数据了‘); res.end(); }); 通过 querystring解析post的数据querystring.parse(‘foo=bar&amp;baz=qux&amp;baz=quux&amp;corge’)// returns { foo: ‘bar’, baz: [‘qux’, ‘quux’], corge: ‘’ } url url.parse(urlStr, [parseQueryString], [slashesDenoteHost])urlStr-&gt;url字符串parseQueryString-&gt;为true时将使用queryString分析查询字符串，默认为falseslashesDenoteHost默认为false，//foo/bar 形式的字符串将被解释成 { pathname: ‘//foo/bar’ }如果设置成true，//foo/bar 形式的字符串将被解释成 { host: ‘foo’, pathname: ‘/bar’ } 服务器相关操作事件和API Event: ‘close’ Event: ‘connection’ Event: ‘request’ server.close([callback]) server.listen(port[, hostname][, backlog][, callback]) 请求对象 Event: ‘data’ message.headers message.httpVersion message.method message.url require(‘url’).parse(request.url) require(‘url’).parse(request.url, true) 响应对象 response.end([data][, encoding][, callback]) response.setHeader(name, value) response.statusCode response.statusMessage response.write(chunk[, encoding][, callback]) response.writeHead(statusCode[, statusMessage][, headers]) gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; npm i -g gulp-cli; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify.pipe(uglify()) 对代码进行合并 gulp-concat.pipe(concat(‘all.js’)).pipe(concat(‘all.css’)) 对css进行压缩 gulp-cssnano.pipe(cssnano()) 对html进行压缩 gulp-htmlmin.pipe(htmlmin({collapseWhitespace:true,minifyJS:false,minifyCSS:true}))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson5","slug":"old_08.node-lesson5","date":"2016-12-23T10:30:50.000Z","updated":"2020-12-16T07:46:41.405Z","comments":true,"path":"2016/12/23/old_08.node-lesson5/","link":"","permalink":"http://blogzhou.top/2016/12/23/old_08.node-lesson5/","excerpt":"node-lesson51.复习1.1node的调试 前两样调试用于面试 node自带的debug调试命令 n下一步 s步入 o步出 node-debug foo.js node-inspector vsc 推荐使用 vsc launch.json 抽风式的好使 ws1.2 es6 用es新特性之前加上严格模式 什么是es？ 为什么用es的新标准？ 为什么前端不用，node要用？es6定义了一个标准—-&gt;let命令—-&gt;js代码里面写了let—-&gt;v8引擎解析，能解析说明支持了es6里的let命令—-&gt;node升级了 严格模式 let const 块级作用域{}let foo =456;{let foo =123;}console.log(foo); 字符串的扩展 includes(str) startsWith(str) endsWith(str) repeat(num) ${变量名}var bar=’暗示的反思’var foo=’123’+’阿斯顿发斯蒂芬’+bar+’是短发飞’;var foo2=阿斯顿发斯蒂芬${bar}是短发飞 箭头函数、 let const 箭头函数 用来看api使用","text":"node-lesson51.复习1.1node的调试 前两样调试用于面试 node自带的debug调试命令 n下一步 s步入 o步出 node-debug foo.js node-inspector vsc 推荐使用 vsc launch.json 抽风式的好使 ws1.2 es6 用es新特性之前加上严格模式 什么是es？ 为什么用es的新标准？ 为什么前端不用，node要用？es6定义了一个标准—-&gt;let命令—-&gt;js代码里面写了let—-&gt;v8引擎解析，能解析说明支持了es6里的let命令—-&gt;node升级了 严格模式 let const 块级作用域{}let foo =456;{let foo =123;}console.log(foo); 字符串的扩展 includes(str) startsWith(str) endsWith(str) repeat(num) ${变量名}var bar=’暗示的反思’var foo=’123’+’阿斯顿发斯蒂芬’+bar+’是短发飞’;var foo2=阿斯顿发斯蒂芬${bar}是短发飞 箭头函数、 let const 箭头函数 用来看api使用 1.3 buffer 创建Buffer Buffer的一些属性和方法 Buffer的一些属性和方法 buf[index] 通过下标访问 buffer 的某个字节的数据 buf.indexOf(value,[byteOffset],[encoding]) 查找某个字符在 buffer 内存中的字节下标 buf.includes(value,[byteOffset],[encoding]) buf.length buf.slice([start,[end]]) buf.toString([encoding],[start], [end]) buf.write(string,[offset],[length],[encoding])1.4 文件流 流对象 stream pipe（）2.网络编程 我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。这些过程都发生了网络数据的交互。bs browser servercs client server 网络编程 是指编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。 强调：网络编程重在思想，node只是一个可以帮助我们网络编程的一个工具而已。使用其他编程语言或者操作系统进行网络编程，思想都是一样的。 什么是服务器？1234服务器就是一个台电脑，是一台性能比较好的大电脑，它需要支持高扩展性，提供服务的服务器一旦部署好服务后，一般动的比较少，linux系统比较常用，不需要比较复杂的可视化操作界面，因为复杂的可视化操作系统比较耗资源，如win10，和windows相比linux比较安全服务器用linux的centos，ubuntu是有桌面版的服务器多用centos 什么是应用服务器？1作为服务器执行共享业务应用程序的底层的系统软件 什么是web服务器？1web服务器是一种应用服务器，提供了web服务，对内提供web应用程序的的运行环境 Apache、Nginx、IIS、tomcat Node 没有 Web 容器如果我用js写了一个web应用程序，那么node就是web服务器.net平台的 ASP或者ASP.net 需要 IIS 作为服务器容器，PHP需要搭载 Apache 或者 Nginx 作为服务器容器，Java 的 JSP 需要 tomcat 作为服务器容器，ruby 的 ruby on rails 需要 搭配 Apache 等作为自己的服务器容器。。。 Node，不需要服务器容器。 Node，不需要服务器容器。 Node，不需要服务器容器。 为什么叫 NodeNode是一个面向网络而生的平台。 Ryan Dahl 在创建Node项目的时候给它起了一个名字叫做 web.js ，就是一个Web服务器。类似于 Apache、tomcat、IIS 等服务器软件。 web.js 的发展超出了作者的最初想法，变成了构建网络应用的一个基础平台。然后就可以在这个基础平台之上构建很多东西，比如服务器、客户端、各种各样的命令行工具等。 Node的目标就是成为一个构建快速、可伸缩的网络应用平台。 每一个Node进程构成网络应用中的一个节点。这就是 Node 的含义。 ipip唯一标识 一台设备端口号标识一个设备上的应用 跨域的场景1.域名不同 （www.wuyou.com 和www.liuxi.com 即为不同的域名）2.二级域名相同，子域名不同 （www.wuyou.wu.com www.liuxi.wu.com 为子域不同）3.端口不同，协议不同 （ http://www.wuyou.com 和https://www.wuyou.com属于跨域www.wuyou.con:8888和www.wuyou.con:8080) 前后分离协议 双方或多方同意，并且达成共识，遵守这样的约束url端口号 ip能够定位电脑，端口号可以定位一个应用程序node 默认是3000 多了往上加 2 http协议通过报文传输 2.1在地址栏输入网址后页面是如何呈现的？ DNS 把域名转化成ip DNS服务器来做这个事情 运营商提供的dns服务器 CDN 内容分发网络 输入 URL：http://www.baidu.com DNS 域名解析 计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置 在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口） 158.12.25.652 域名就是为了好记 为了好记，所以我们的 万维网提供了 一个 域名这样的概念 当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器， 将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器 浏览器将用户输入的 URL 地址根据HTTP协议 封装成了 http 请求报文（请求头+请求行+请求体） 该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器 后台服务器接收到用户HTTP Request 请求报文 后台服务器接收到 客户端发送给自己的数据（二进制数据） 首先把二进制数据按照编码解析成字符，（人类可以识别的） 解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来 后台服务器处理用户请求信息 当得到用户请求报文之后，根据请求报文中的 get、port或者 URL、或者URL中的查询字符串或者 请求体中的数据 根据用户的特定的请求数据做特定的处理 后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端 当我们解析和处理完用户请求报文消息之后 服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文 响应头、响应字段、响应体 该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端 发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单 用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码 当客户端解析到 服务器发送过来的 二进制数据 客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串 然后根据 HTTP 协议，解析服务器发送过来的 响应报文 然后根据响应报文中的报文内容（报文头、报文体）做具体的解析 当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤2.2HTTP协议HTTP协议就是 浏览器 和 服务器 之间通信的一个数据格式规范 在HTTP协议中，始终是以一种 一问一答 的形式在进行沟通和交流（数据交换） 服务器如果没有收到浏览器的请求消息，服务器永远不会主动的发送响应消息 浏览器不发出请求，服务器不会主动的发送响应 浏览器发送请求数据到服务器 服务器解析浏览器发送的请求数据 服务器响应数据到客户端浏览器 2.3cookie&amp;session http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的 cookie 信物，客户端请求服务器了以后，服务器给客户端一个信物，下次客户端再请求服务器的时候，给服务器这个信物服务器就知道是哪个客户端了 缺点是，不能存储太多内容、不安全 session 存储在服务器端的，保存着用户信息的，和cookie搭配来使用，可以用cookie里面的key对应上session里面的值session可以存在内存或硬盘上都可以。 2.4前后端分离 2.5 loaclhost 127.0.0.1 ip地址 Nginx代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。123nginx除了是个web服务器还能够做反向代理服务器，反向代理服务器的作用，可以用来做负载均衡代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。 可以用nginx来做负载均衡","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson4","slug":"old_07.node-lesson4","date":"2016-12-15T03:30:50.000Z","updated":"2020-12-16T07:46:11.553Z","comments":true,"path":"2016/12/15/old_07.node-lesson4/","link":"","permalink":"http://blogzhou.top/2016/12/15/old_07.node-lesson4/","excerpt":"#node-lesson4 ###1.1什么是io?1io 是输入输出 文件操作的读写 网络操作中的请求和应答 ###1.2进程和线程？12345进程是为运行中的应用程序提供运行环境的线程就是执行应用程序当中的代码的同一时间只干一件事情node中异步就是帮你完成多线程编程多线程编程比较复杂 ###1.3同步和异步？12同步会阻塞代码异步不会阻塞代码","text":"#node-lesson4 ###1.1什么是io?1io 是输入输出 文件操作的读写 网络操作中的请求和应答 ###1.2进程和线程？12345进程是为运行中的应用程序提供运行环境的线程就是执行应用程序当中的代码的同一时间只干一件事情node中异步就是帮你完成多线程编程多线程编程比较复杂 ###1.3同步和异步？12同步会阻塞代码异步不会阻塞代码 ###1.4事件驱动模型1234567891011121314151617主线程：1.执行node的代码，把代码放入队列2.事件循环程序（主线程）把队列里面的同步代码都先执行了，3.同步代码执行完成，执行异步代码4.异步代码非2种状况， 1异步非io setTimeout() setInterval() 判断是否可执行，如果可以执行就执行，不可以跳过。 2异步io 文件操作 会从线程池当中去取一条线程，帮助主线程去执行。5主线程会一直轮训，队列中没有代码了，主线程就会退出。子线程：被放在线程池里面的线程，用来执行异步io操作 1.在线程池里休息 2.异步io的操作来了，执行异步io操作。 3.子线程会把异步io操作的callback函数，扔回给队列 4.子线程会回到线程池了去休息。 callback 在异步io代码执行完成的时候被扔回主线程。 ###1.5文件操作1234567- fs.readFile() 读文件- fs.access() 判断路径- fs.writeFile() 写文件- fs.appendFile() 在文件的内部去追加写一些内容- fs.mkdir() 创建文件夹- fs.stat() 判断文件文件夹，文件/文件夹的属性- fs.readdir() 迭代 f(1),f(2),f(3),f(4)……递归 f(f()),f(f(f())),f(f(f(f())))….. ###1.6path path.join(“/a”,”/b”,,,,,) #1.7 $http $http({ method: ‘GET’,//发送get请求 url: ‘http://127.0.0.1:3000/in_theaters/&#39;}).then(function(data){},function(error){}) .then的成功方法里面返回的data是整个报文，如果取里面json数据需要data.data.success的方式去取的data是报文体，data就是数据 #2.node的调试 ###2.1 node自带的debugg ###2.2 node-inspector第三方的调试包 ###2.3 vsc 调试 ###2.4 ws 调试 ###2.5异常处理error .message .stack .code var err =new Error(‘这是一个自定义错误’); 其它 vsc教程http://i5ting.github.io/vsc/#3.es6###3.1什么是es6？1ECMAScript es标准的作用 定义js的发展方向的一套标准 ###3.2为什么用es6？1新的语法，写起来更严谨更安全更简便。 ###3.3为什么前端不用，node要用？12345js---&gt;浏览器--&gt;引擎执行js代码ie ff chromenode----&gt;v8执行js代码node 不考虑兼容性，es6能给我们带来很多好处。Node.js 6覆盖了93%的ECMAScript 6 阮一峰es6入门###3.4 use strict严格模式 123456789消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。&apos;use strict&apos;保留字：一旦出现Unexpected strict mode reserved word这样的错误说明你用保留字做了参数名了。es6--&gt;implements, interface, let, package, private, protected, public, static, yieldes5--&gt;class, enum, export, extends, import, super 阮一峰 严格模式 ###3.5 let在使用let命令声明变量时，一个变量名只能声明一次，不存在命名冲突。let定义作用域在代码块里,解决命名冲突问题，能体现代码的封装性变量提示，用let不存在变量提示，会直接报错，告诉你变量没有定义let命令每次定义的作用域都在本次循环的方法体内 ###3.6 const//定义常量，不会发生变化//如定义了常量，再去修改就会报错error Assignment to constant variable 不可以给常量赋值//const定义的常量，作用域与let相同//应用场景const用来定义静态变量,加载模块的时候，定义个常量，把模块赋值给常量 ###3.7 块级作用域凡是被{}包裹的代码属于一个代码块 ###3.8promisehttps://cnodejs.org/topic/560dbc826a1ed28204a1e7de异步流程控制的解决方案回调地狱 异步流程—&gt;回调函数的嵌套 异步流程控制—-&gt;用同步的方式去写异步的代码 ###3.8 字符串的一些扩展${} 4. 文件操作4.1 Buffer十六进制：0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 满16进位 所以 0X10=16计算机最早诞生的时候，没有中文，在美国 26个英文字母，@ ! , . - + = 计算机只能识别 0 或者 1 把你的字符和计算机真正存储的二进制数据做了一个字典： 可以通过 开源中国 官网网站提供的一个工具页面：http://tool.oschina.net/ 随着计算机普及到了世界各地，ASCII 码 已经不能满足世界各地人们的需求了 计算机进入中国之后，后来在原来的 ASCII 码基础之上扩展了一个新的字符集编码：gb2012，字典 大字典utf-8用来支持中文字节的转化 1汉字=2字节 00100010 000000001字节（Byte)＝8字位＝8个二进制数1字位(bit)＝1个二进制数1B=8b1KB=1024B1MB=1024KB1GB=1024MB 4.1.1 创建BufferBuffer 是一个像 Array 的对象，它的元素为16进制的两位数（0-255的值），主要用于操作字节，Buffer 是一个全局对象，使用的时候不需要 require new Buffer(size) new Buffer(str,[encoding]) 4.1.2 Buffer的一些属性和方法 buf[index] 通过下标访问 buffer 的某个字节的数据 buf.indexOf(value,[byteOffset],[encoding]) 查找某个字符在 buffer 内存中的字节下标 buf.includes(value,[byteOffset],[encoding]) buf.length buf.slice([start,[end]]) buf.toString([encoding],[start], [end]) buf.write(string,[offset],[length],[encoding]) 4.1.3 造成乱码的原因我们通常所说的编码一般就是指 字符集编码，一般用于字符串 当你把一个 gbk 编码文件发送给了你的一个国外友人的时候，乱码的原因就是：他的机器上没有该编码 计算机为了让多语言操作系统下可以识别和共享一种编码格式：所以诞生了 超级大字典：utf-8 造成乱码的原因其实就是 读取的编码和文件的编码不一致 要想解决乱码：让文件编码和读取编码统一即可 什么是字符集编码 为什么要有编码 计算机只能识别二进制 为了让计算机可以识别字符，人类做了一个字典 二进制 -&gt; 字符 的映射关系 为什么会产生乱码 文件编码和读取该文件的编码不一致导致的 如何解决乱码 让文件和读取的字符编码集一致即可 如何解决 Node 原生不支持的一些编码 通过 第三方包：iconv-lite 该第三方包可以解决 gbk 等编码不支持的问题###4.2文件流 流对象 stream fs.readFile()和fs.writeFile()问题？ 对大文件的处理，例如下载 通过文件流的形式传输大文件 const rs = fs.createReadStream(path1); const ws = fs.createWriteStream(path1); rs.pipe(ws);-如何去控制流。我们可以通过监听stream对象里面的事件，去控制读写流。 其它 vsc教程http://i5ting.github.io/vsc/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson3","slug":"old_06.node-lesson3","date":"2016-12-08T02:30:50.000Z","updated":"2020-12-16T07:58:47.382Z","comments":true,"path":"2016/12/08/old_06.node-lesson3/","link":"","permalink":"http://blogzhou.top/2016/12/08/old_06.node-lesson3/","excerpt":"","text":"#node-lesson3 1.0 nvm常用命令 nvm项目地址：nvm-github地址 查看所有已安装的本地的node版本nvm list 切换node版本nvm use 版本号 安装指定版本的nodenvm install 版本号 位数 卸载已安装的指定版本的nodenvm uninstall 版本号 ###1.1模块的分类 ```12345678910111213141516- 核心模块 + fs file system + http + os + path + querystring + url&lt;!--more--&gt;###1.2模块三兄弟 require、module、exports- require的实现原理```把代码从文件中读出来，用匿名函数的方式头尾包装，返回modules.exports对象，曝露出想要曝露出来的属性、方法、对象。 补充了exports是指向modules.exports的一个指针，exports能做的，modules.exports都能做的。 require查找文件、包原理 12第二次加载的时候优先从缓存查找读取，node_modules中没有的，从父文件夹中查找，如果没有，直到根目录为止 module 1里面保存了模块的信息路径、父子信息、曝露出的对象信息 exports 123module.exports 别名module.exports=123;已经使用过一次了，exports就不生效了module.exports.a=12;这样使用,exports是还可以使用的 ###1.4包123package.json是包的说明书，dependencies当前包所依赖的包：&gt;、&lt;、&gt;=、&lt;=、~、*、&quot; &quot;、X、^、 devDependencies 开发环境中包所依赖的包： ###1.5npm12345678npm init 创建package.json文件npm install 将package.json中的文件依赖的包从网上下载到本地npm install -save 包名 将包下载下来并且加载到dependencies中去npm i -S 包名 替代上面的命令npm install -save-dev 包名 将包下载下来并且加载到devDependencies中去npm i -D 包名 替代上面的命令npm install -g 包名 全局安装 安装的是全局工具npm docs 包名 查看包的文档 ###1.6nrm npm的数据源管理工具123nrm ls 查看npm的数据源nrm use 切换npm下载包的地址nrm test 测试下哪个数据源快 1.7 3mnpm node的包管理工具nvm node的版本管理工具nrm npm的数据源管理工具 ###1.8箭头函数1语法糖替代function()&#123;&#125; v=&gt;v #2.i/o ###2.1什么是i/o？ 12io input、output 输入输出，电脑的输入输出，例如音频录音表示声音输入、听音乐是声音的输出网络上的传输全部是在传字符串，i/o在服务器上可以理解为读写操作。 ###2.2什么是并发？1一个时间段中有几个程序都处于已启动运行到运行完毕之间。 #3异步i/o与事件驱动 ###3.1什么是进程？12进程是为运行当中的应用程序提供运行环境的一个运行当中的应用程序就会有一个进程与之相对应 ###3.2什么是线程？1234线程是用来运行应用程序中代码的，一个线程在一个时间只能做一件事件。多线程，调度起来很麻烦。node是单线程执行，用异步替代了多线程 ###3.3同步、异步有什么不同？12异步不会阻塞后面的代码，同步会阻塞后面的代码一条线程先执行同步的代码后执行异步的代码。 ###3.4异步非i/o操作和异步i/o操作12异步非io setTimeout setInterval异步IO操作 操作文件 网络操作 fs ###3.5node的事件驱动模型？12 ###3.5异步和多线程的比较？1node的异步是帮助我们去做了多线程的操作，简化了代码 #4.文件操作 ###4.1文件的完整读写12fs模块---》操作文件---》io----》node的特长fs模块是node非常重要的模块，能体现出node的优势 fs.readFile() 读文件 fs.writeFile() 写文件 fs.appendFile() 在文件的内部去追加写一些内容 fs.mkdir() 创建文件夹 fs.readdir() 读文件夹 fs.access() 判断路径 fs.stat()isFile：用于判断被查看的对象是否为一个文件，如果是返回true，否则，返回false；isDirectory：用于判断被查看的对象是否为一个目录，如果是的话则返回true，否则，返回false；isSymbolicLink：用于判断被查看的文件是否为一个符号链接文件，如果是的话则返回true，否则，返回false。该方法仅在lstat方法的回调函数中有效； #5.异常处理什么是异常？计算机不能处理的状况称之为异常try catch 只能捕获同步异常try { fs.accessSync(‘./02sfdasdfio.js’);} catch (err) { console.log(“1”+err);}异步异常对象和被try catch捕获的对象是一样的 #6.path","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson2","slug":"old_05.node-lesson2","date":"2016-11-28T08:50:30.000Z","updated":"2020-12-16T07:38:00.857Z","comments":true,"path":"2016/11/28/old_05.node-lesson2/","link":"","permalink":"http://blogzhou.top/2016/11/28/old_05.node-lesson2/","excerpt":"node-lesson21.1 概念 Node.js与JavaScript的关系? Node.js基于哪个JavaScript引擎？ Node.js的特点？ Node.js只能运行在Windows上吗？ 1.2 cmd cd（change directory）切换目录 md（make directory）新建目录 rd（remove directory）删除非空目录 dir（directory）查看目录中的条目ls linux ren（rename）重命名文件 del（delete）删除文件 cls（clear screen）清屏clear linux","text":"node-lesson21.1 概念 Node.js与JavaScript的关系? Node.js基于哪个JavaScript引擎？ Node.js的特点？ Node.js只能运行在Windows上吗？ 1.2 cmd cd（change directory）切换目录 md（make directory）新建目录 rd（remove directory）删除非空目录 dir（directory）查看目录中的条目ls linux ren（rename）重命名文件 del（delete）删除文件 cls（clear screen）清屏clear linux 1.3 path 环境变量 path环境变量的作用是什么？ 在Windows中配置path环境变量的方法是什么？ 1.4 REPL（Read Eval Print Loop）交互式运行环境 作用：一般来说，可以用来做一些API的测试 进入REPL运行环境 退出REPL运行环境 1.5 Node.js基础知识 如何让Node.js执行一个js文件node 文件名 -绝对路径和相对路径 .\\或者..\\ 相对路径 c:/xx/xx.js绝对路径 \\ linux 根目录 windows 盘符的根目录 1.6 globals global __dirname和__filename关于这俩家伙，一般在读取文件的时候，最好使用绝对路径的方式，通过这俩家伙拼接 console assert(foo==1,”失败”);断言 time(‘timer’) timeEnd(‘timer’) 成对的出现 1.7 模块系统 什么是模块一个文件就是一个模块 模块作用域在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。 requirerequire(&quot;路径&quot;)//路径现阶段使用相对路径 exports是module.exports的一个别名、引用，exports能做的module.exports都可以完成。 module.exports最终曝露出去的对象，想曝露出去对象、属性、方法就挂载到module.exports #2.模块系统 ##2.1模块的种类 在Node.js中，模块分为两类：12345678910第一类，核心模块（原生模块），node自带，用名称直接可以加载。- 核心模块 + fs file system + http + os + path + querystring + url ...第二类，文件模块，用路径加载，有一种特殊的文件模块-----&gt;包，可以用名字。 module 是一个全局对象，它的作用是存储模块信息的,每一个js是一个模块，每一个模块里面都有一个module，module里面还存储了父子结构直接给module.exports赋值，exports是无效，用属性的形式去赋值的时候二者都有效 2.2 优先从缓存加载1common.js规范-----&gt;加载后，再次加载时，去缓存中取module.exports 2.3 require参数解析 1234核心模块是Node.js原生提供的加载核心模块的时候，不需要传入路径，因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了在加载的过程中，原生的核心模块的优先级是是最高的 ./或../开始的相对路径文件模块 和 你要加载的模块的文件名拼接 ```1- 以/开始的绝对路径文件模块 在Linux或者MAc的操作系统中，/表示系统的根路径 在Windows中，/表示当前文件模块所属的根磁盘路径不建议使用，了解12- 标识符中可以不包含扩展名 + Node会按照`.js、.node、.json`的次序补足扩展名，依次尝试 不包含扩展名的时候，Node.js会按照 路径.js 以后自己在加载js文件模块的时候，就省略掉.js后缀就可以了 路径.node 后缀为node的文件是c/c++写的一些扩展模块 路径.json 如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度 .json文件最终Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象 Node.js会通过同步阻塞的方式看这个路径是否存在 依次尝试，直到找到为止， 如果找不到，报错 123456 - require 加载包的时候``` 直接写包名，先在包内的node_modules, 目录下查找，去父级目录下的node_modules目录下查找， 依次向上查找，直到根目录。 参考文献 3.包还有一种特殊的文件模块，其实就是包 问题：你开的一个功能模块，还是以文件的形式散列的，你给别人使用的时候很麻烦。 包的作用：在模块的基础上进一步组织JavaScript代码 3.1 包的组成 包结构 包描述文件package.json 描述你的当前的包的一些相关的信息+dependencies 包名：“版本号” +版本号 下载大于某个版本号，npm会下最新版 &lt; +版本号 下载小于某个版本号，npm会下小于这个版本号最新版 &lt;= 小于等于 一定会下你写的这个版本，除非没有你写的这个版本 = 大于等于 下载最新版 *、” “、X 任意 npm会给你下最新版 ~ +版本号 会去下约等于这个版本的最新版，在大版本不变的情况下下一个比较新的版本 ^ +版本号 不跃迁版本下载，^2.1.0 npm会下载大版本不变，去下载2.x.x版本里的最近版 参考文献 package.json全字段解析 ##npm install -g fast-init 3.2 package.json包的描述文件 package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置，比如name就是项目名称，version就是项目的版本号 在模块的加载机制中，有一个main属性是非常重要的，它很大意义上决定了包要导出的模块位置 3.3npm 基于Node.js开发的包的托管网站 Node.js包管理工具 npm :基于包的规范实现的一个包管理工具 npm install 包名 当执行npm install的时候，它会自动跑到npm的网站，然后找到该包的github地址，找到之后，下载这个压缩包，然后在执行npm install的当前目录下找一个叫做node_modules目录如果找到，直接解压这个压缩包，到node_modules目录下如果找不到，则新建一个node_modules目录，解压到该目录 npm install -g 包名 表示全局安装 npm在安装的时候，在全局设置了一个安装目录，只要是全局安装就会把包安装到这个目录里面去 npm install -g 包名 只要是全局安装就是安装命令行工具 npm install 缩写 npm i 当执行npm install的时候，会自动在当前目录中查找package.json文件如果找到，找里面的 dependencies 字段，安装该字段中所有依赖的项 npm docs 包名通风这个命令打开 包相对应的文档 npm install –save 生产环境npm i -S jquery@3.*咱们以后在做项目的时候，先初始化一个package.json文件，在安装第三方包依赖的时候，必须使用npm install –save express,添加依赖项到package.json文件中，实际就是添加到dependencies字段中 npm install -save-dev 开发环境npm i -D jquery@3.*咱们以后在做项目的时候，先初始化一个package.json文件，在安装第三方包依赖的时候，必须使用npm install –save express,添加依赖项到package.json文件中，实际就是添加到devDependencies字段中 npm config set prefix 修改全局安装目录不建议使用，建议去文件夹里面改 C:\\Users\\用户名 里面有一个 .npmrc文件去里面改prefix = C:\\dev\\npm （写你的路径）去全局的环境变量path里把C:\\dev\\npm 路径加进去 参考文献 npm的命令 npm 这种东西的最终的目的就是：让你的开发模式工程化，都依靠工具来管理nvm npm nrm3m12345nvm node版本的管理工具npm node的包管理工具nrm npm的数据源管理工具 npm install -g nrm #4.文件操作 ###4.1箭头函数12345678910111213141516171819202122箭头函数就是一种语法糖语法糖是一种语法，用这种语法能尝到甜头，能是编程高效当函数体有一个参数有返回值的时候var foo=function(v)&#123; return v;&#125;var foo=v=&gt;v;当函数体没有参数有返回值的时候var foo=function()&#123; return v;&#125;var foo=()=&gt;v;当函数体有多个参数有返回值的时候var foo=function(v1,v2)&#123; return v1+v2;&#125;var foo=(v1,v2)=&gt;v1+v2;当函数体有多个参数没有返回值的时候var foo=function(v1,v2)&#123; console.log(v1); console.log(v2); &#125;var foo=(v1,v2)=&gt;&#123; console.log(v1); console.log(v2); &#125;; ###4.2文件读写 fs.readFile() 读文件 fs.readFile(file, [options], callback)//file 读文件的路径//options 用[]包裹的可选参数，object {“encoding”:”uft8”,”flag”:”r”} string ‘utf8’//callback function callback函数里面有两个参数//err表示错误对象，如果readFile发生错误了，在callback函数里面会回返回err，err对象里面存着错误信息//如何读文件成功，err为null//data就是读文件，读出来的内容。 fs.access(path,[mode], callback) 用来判断文件是否存在//path 判断路径是否正确（也可以判断文件）’./pic’//mode一般不用，默认就可以了，用的话是用来判断文件是否可读可写可执行//callback 只有一个参数err，错，文件有问题 其它 vsc教程http://i5ting.github.io/vsc/ nrm ls 查看数据源nrm test 测试你的网连那个npm的数据源快nrm use 切换数据源5.阅读参考文献 朴灵 require阅读参考文献 package.json全字段解析6.github自己玩玩","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"node-lesson1","slug":"old_04.node-lesson1","date":"2016-11-21T04:31:30.000Z","updated":"2020-12-16T07:35:11.562Z","comments":true,"path":"2016/11/21/old_04.node-lesson1/","link":"","permalink":"http://blogzhou.top/2016/11/21/old_04.node-lesson1/","excerpt":"#node-lesson1 ##1.解决几个问题？ ###1.前端、后端都是干什么的？前端 做静态资源的后端 操控服务器的硬件的 ###2.为什么学习node.js？1.就业有市场2.有商业用途国内一些创业公司用用的比较多，功夫熊（做上门保健的，美甲、按摩）国外的一些大公司都有使用：Facebook、Twitter、Google国内的一些大公司：Alibaba（天猫所有的页面都是通过Node提供的服务）、Tencent、Baidu3.本身技术是有价值4.js开发 ###3.什么是JavaScript？一门脚步语言 需要嵌入html执行 ###4.浏览器中的JavaScript可以做什么？校验表单 操作dom 等等 ###5.浏览器中的JavaScript不可以做什么？操作服务器硬件","text":"#node-lesson1 ##1.解决几个问题？ ###1.前端、后端都是干什么的？前端 做静态资源的后端 操控服务器的硬件的 ###2.为什么学习node.js？1.就业有市场2.有商业用途国内一些创业公司用用的比较多，功夫熊（做上门保健的，美甲、按摩）国外的一些大公司都有使用：Facebook、Twitter、Google国内的一些大公司：Alibaba（天猫所有的页面都是通过Node提供的服务）、Tencent、Baidu3.本身技术是有价值4.js开发 ###3.什么是JavaScript？一门脚步语言 需要嵌入html执行 ###4.浏览器中的JavaScript可以做什么？校验表单 操作dom 等等 ###5.浏览器中的JavaScript不可以做什么？操作服务器硬件 ###6.浏览器与JavaScript是什么关系？浏览器解析js，目的是为了让计算机能看懂js，看懂01010101，机器码、字节码编译 内核–&gt;js引擎 引擎 1.转化 汽油柴油等等-&gt;转化-&gt;成动能 模板+数据—&gt;页面 js代码—&gt;机器码\\字节码 2.移植性 js引擎套一个壳子，写js代码传给js引擎，操作硬件 node.js v8引擎去解析js ###7.JavaScript只可以运行在浏览器中吗？ ##什么是 Node? https://nodejs.org/en/ node是js运行环境基于v8引擎特点用事件驱动、无阻塞的io模型优势轻量、高效 node是门技术不是语言java java.net c#node js Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. JavaScript runtime JavaScript 运行时 Chrome’s V8 JavaScript engine Chrome 浏览器 V8 引擎 Node.js 是一个 构建于 谷歌的 Chrome 浏览器的 V8 引擎之上的一个 JavaScript运行时 环境 Node.js可以解析和执行 JavaScript 代码 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. event-driven 事件驱动模型 non-blocking I/O model 非阻塞IO模型 IO（input/output）输入与输出 lightweight[ˈlaɪtweɪt] 轻量级 在软件开发行业中，轻量级标识褒义词 轻量级也就意味着 运行速度快 轻量级也就意味着有更好的 跨平台 特性（平台的差异性，兼容性） efficient[ɪˈfɪʃnt] 高效的 Node.js的 事件驱动和非阻塞IO模型使得Node.js本身非常的轻量和高效 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. package ecosystem npm 包生态系统 npm largest 最大的 open source libraries 开源库 理论意义上 开源就表示有成熟的社区，开放源代码 Node.js 的npm包生态系统，是世界上 最大的 开源库 生态系统 以前的 客户端中 JavaScript 库 散列在互联网的各个地方 npm 就是 把大家经常使用的一些开源库 给 组织到了一起 Node 是一个可以解析和执行 JavaScript 代码的 运行时环境 Node.js 的作者 瑞恩.达尔 Node 的实现结构 V8 JavaScript 解析执行引擎 ECMAScript 中间层 （提供了文件操作、网络操作登陆接口）更加接近操作系统的接口供开发人员使用 硬件层 安装与配置3m安装法 nvm npm nrm安装包的方式安装 问题1：安装了node 没有卸载 2:32和64搞混了 3：；拼写错误，路径错误——&gt;老师眼力 下载地址： 一路下一步 next 如何确认是否安装成功： win + r ，然后输入 cmd ，然后敲回车 就可以进入 cmd 控制台 nvm 安装和管理我们的 Node.js版本1234567nvm的安装方式，node.js version manager 是一个node的版本管理工具为了解决node版本切换问题右键在此电脑上点击一下--》属性---》系统---》高级系统设置---》环境变量控制面板---》系统---》高级系统设置---》环境变量NVM_HOME---C:\\dev\\nvmNVM_SYMLINK--C:\\dev\\nodejs新建一个path %NVM_HOME%;%NVM_SYMLINK% nvm 用法查看版本号nvm list用哪个版本（已经下载过的版本）nvm use 版本号nvm use 版本号 32下载相对应版本nvm install 版本号nvm install 版本号 32 nvm下载的是二进制版本123456789101112131415## 控制台基本使用允许用户可以在终端命令台中与操作系统交互，其实就是输入与输出### 如何打开cmd1. 通过 按 window 键，输入 `cmd` 打开cmd程序2. 通过 `win+r` 输入 `cmd`，敲回车就可以进入### 基本命令- `dir` directory 列出当前目录下所有的条目 + 别名 `ls` 在 powershell 中可以使用- `cd` change directory 切换目录 切换到当前目录下的 Desktop 目录当想切换到当前目录的时候，最好使用 cd ./ 相对路径的形式C:\\Users\\iroc&gt;cd DesktopC:\\Users\\iroc\\Desktop&gt; 在Windows 上切换盘符：d: 切换绝对路径之后再同一个盘符下才有效 切换到上一级目录C:\\Users\\iroc\\Desktop\\code\\seajs&gt;cd ../C:\\Users\\iroc\\Desktop\\code&gt; 连续进入多级目录C:\\Users\\iroc\\Desktop\\code&gt;cd seajs/aC:\\Users\\iroc\\Desktop\\code\\seajs\\a&gt;123456789101112131415161718192021222324252627282930313233343536373839404142- `cls` clear screen 清屏 + 别名 clear 在widnows中的 `powershell` 中可以使用 windows下的寻址用\\反斜杠 ### path 环境变量目的是为了在控制台中的任何目录都可以快速打开或者使用该可执行文件环境变量就是用来存储系统级别的变量- 添加环境变量 + 我的电脑 -&gt; 右键选择属性 -&gt; 高级系统设置 -&gt; 切换到`高级`面板 -&gt; 环境变量 + 第一种方式：直接把可执行文件所属的目录 放到 PATH 环境变量中（如果没有PATH环境变量，自己新建） + 第二种方式：新建一个环境变量，变量名规范：逻辑名_HOME 变量值：该可执行文件所属的目录 + 注意：无论是直接添加的路径还是引用的变量名，一定要用 英文的分号 区分开 + 引用变量名的时候，变量名两边都是 `%``&gt; feiq`当你在控制台中输入一个程序的名字的时候，cmd 默认把它当成一个可执行文件去执行了，优先找当前目录下是否有没有一个叫做feiq.exe 的可执行文件，如果有，直接执行打开如果没有，cmd会进入 path 环境变量中 一个目录一个目录的挨着查找里面是否有该可执行文件## REPL(Read-eval-print-loop) 运行环境用来测试一下代码的，repl和chrome的控制台很像- 通过在控制台中输入 `node` 敲回车就可以计入 REPL 运行环境- 通过在REPL运行环境中 连续按两次 `Ctrl+C` 就可以退出 REPL 运行环境## 执行js文件 用node执行js文件，文件在当前目录下----&gt;node +文件名 如果不在当前目录下，node +文件路径的形式执行 相对路径 ./当前路径 ../上级目录 绝对路径执行js的方式 node c:\\Users\\cena\\Desktop\\code\\01helloworld.js## Globalglobal和window很像，都是全局对象## CONSOLE 断言 是用来测试用的断言就是假定一个条件，如果条件成立则不输出任何内容，如果条件不成立则报错还要输出想要输出的内容。console.assert(条件,条件不成立输出的内容);var foo=3;console.assert(foo==3,”失败”);time() timeEnd()成对出现，计算在两个方法中间的代码的运行时间，传入的参数要一致console.time(‘test’); console.timeEnd(‘test1’);1234567891011121314151617181920212223### __dirname 和 __filename__dirnamee 用来找到当前文件夹的路径__filename 用来去到当前文件的路径不知道代码要才哪使用的时候，用于灵活的写代码取路径的时候。它们属于模块作用域，可以直接使用它们两个用来获取路径的，一般用于操作文件路径的时候，才会用到## processprocess 是一个全局可用对象，用来和我们现在启动中的node进行交互的process.version取版本号在控制台做标准输出process.stdout.write(`123123`);process.pid：当前进程的进程号。process.version：Node的版本，比如v0.10.18。process.platform：当前系统平台，比如Linux。process.env：指向当前shell的环境变量，比如process.env.HOME。process.stdout：指向标准输出。process.stdin：指向标准输入。process.stderr：指向标准错误。## 模块系统## node.js模块化 一个js文件在node里面我们就理解为一个模块require用来加载模块module.exports用来曝露属性和方法的，因为模块有封装性，需要打破封装性曝露方法和属性来exports是module.exports的别名，exports可以做的事情，module.exports都可以做，exports只能用.的形式曝露属性和方法`","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"JavaScript 模块化编程","slug":"old_03.JavaScript 模块化编程","date":"2016-11-11T02:31:30.000Z","updated":"2020-12-16T07:34:56.043Z","comments":true,"path":"2016/11/11/old_03.JavaScript 模块化编程/","link":"","permalink":"http://blogzhou.top/2016/11/11/old_03.JavaScript 模块化编程/","excerpt":"JavaScript 模块化编程网站越来越复杂，js代码、js文件也越来越多，会遇到什么问题？1.命名冲突 2.文件依赖问题 什么是模块化模块化开发演变全局函数 命名冲突 文件依赖的问题 对象封装 用命名空间的方式进行封装 先约定命名的规范的形式 对象里面的属性和方法很容易被修改掉，很不安全 划分私有空间-通过匿名函数自执行的方法封装模块，-可以保护私有变量和方法 模块的维护扩展 开闭原则，对修改关闭，对扩展开放。 增加了代码的健壮性和容错性 模块的第三方依赖 模块职责唯一性 把依赖的模块，通过依赖注入的形式，在你的参数上进行体现。","text":"JavaScript 模块化编程网站越来越复杂，js代码、js文件也越来越多，会遇到什么问题？1.命名冲突 2.文件依赖问题 什么是模块化模块化开发演变全局函数 命名冲突 文件依赖的问题 对象封装 用命名空间的方式进行封装 先约定命名的规范的形式 对象里面的属性和方法很容易被修改掉，很不安全 划分私有空间-通过匿名函数自执行的方法封装模块，-可以保护私有变量和方法 模块的维护扩展 开闭原则，对修改关闭，对扩展开放。 增加了代码的健壮性和容错性 模块的第三方依赖 模块职责唯一性 把依赖的模块，通过依赖注入的形式，在你的参数上进行体现。 总结 最大的问题，规范的问题 如果在多人协作开发过程中，会有很大的问题 多人协作开发过程中：代码的风格一定要统一 模块化规范服务器端模块化规范浏览器端模块化规范 AMD RequireJS CMD SeaJScommonjs node.js SeaJS基本使用整体感知定义模块 define 定义模块 define(function(){}) 函数体内的方法属性都属于这个方法，对外有封装性;解决了命名冲突问题，使js代码有了封装性 直接调用 jQuery 插件等非标准模块的方法 http://my.oschina.net/briviowang/blog/208587 启动模块 seajs.use 加载入口模块，我们把define定义的js就叫模块 这个用于在html代码里面的加载加载模块 require-加载文件依赖、模块依赖的，用于define函数体内暴露接口 exports 和 module.exports module.exports曝露出一个完整的对象，只能扔一次只能曝露出来一个 exports是module.exports的别名，可以用来单个属性、方法、对象的曝露，用.的形式,exports能做的事情module.exports也可以做 使用场景用.属性的形式曝露属性和方法的时候，而且是多个的时候用exports module.exports直接等于的方式用，直接等于一个方法属性对象等等~~~##requirejs与seajs的区别requirejs是优先加载的seajs是懒加载的，就是有拖延症，用的时候才加载http://www.requirejs.cn/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blogzhou.top/categories/javascript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blogzhou.top/tags/JS/"}]},{"title":"深入理解CADisplayLink和NSTimer","slug":"old_01.深入理解CADisplayLink和NSTimer","date":"2016-01-25T02:31:30.000Z","updated":"2020-12-16T06:09:57.784Z","comments":true,"path":"2016/01/25/old_01.深入理解CADisplayLink和NSTimer/","link":"","permalink":"http://blogzhou.top/2016/01/25/old_01.深入理解CADisplayLink和NSTimer/","excerpt":"深入理解CADisplayLink和NSTimer 一、什么是CADisplayLink简单地说，它就是一个定时器，每隔几毫秒刷新一次屏幕。 CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性:提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。 我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。 frameInterval属性:是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。 pause属性:控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的target跟selector timestamp属性: 只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。 打印timestamp值，其样式类似于：179699.631584。","text":"深入理解CADisplayLink和NSTimer 一、什么是CADisplayLink简单地说，它就是一个定时器，每隔几毫秒刷新一次屏幕。 CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性:提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。 我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。 frameInterval属性:是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。 pause属性:控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的target跟selector timestamp属性: 只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。 打印timestamp值，其样式类似于：179699.631584。 另外 CADisplayLink 不能被继承。 给非UI对象添加动画效果 我们知道动画效果就是一个属性的线性变化，比如 UIView 动画的 EasyIn EasyOut 。通过数值按照不同速率的变化我们能生成更接近真实世界的动画效果。我们也可以利用这个特性来使一些其他属性按照我们期望的曲线变化。比如当播放视频时关掉视频的声音我可以通过 CADisplayLink 来实现一个 EasyOut的渐出效果：先快速的降低音量，在慢慢的渐变到静音。 注意 : 通常来讲：iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是CADisplayLink调用的target的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。 在mac应用中我们使用的不是CADisplayLink而是 CVDisplayLink它是基于C接口的用起来配置有些麻烦但是用起来还是很简单的。 #####二、CADisplayLink 与 NSTimer 有什么不同? 1.原理不同 CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。 NSTimer以指定的模式注册到runloop后，每当设定的周期时间到达后，runloop会向指定的target发送一次指定的selector消息。 2.周期设置方式不同 iOS设备的屏幕刷新频率(FPS)是60Hz，因此CADisplayLink的selector默认调用周期是每秒60次，这个周期可以通过frameInterval属性设置， CADisplayLink的selector`每秒调用次数=60/ frameInterval。比如当 frameInterval设为2，每秒调用就变成30次。因此，CADisplayLink `周期的设置方式略显不便。 NSTimer的selector调用周期可以在初始化时直接设定，相对就灵活的多。 3、精确度不同 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 4、使用场景 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。 NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。 #####三、CADisplayLink和NSTimer的使用 CADisplayLink的使用 1.创建方法123self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; 2.停止方法123[self.displayLink invalidate]; self.displayLink = nil; 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。 NSTimer的使用 创建方法 123456789NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:NO]; TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法 target : 需要执行方法的对象。 selector : 需要执行的方法 repeats : 是否需要循环 释放方法 1[timer invalidate]; 注意 :调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。 特性 存在延迟 ，不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。 注意：必须加入Runloop 使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop:123NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://blogzhou.top/categories/iOS开发/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://blogzhou.top/tags/OC/"}]}]}